// Generated by Melange

import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Queue from "bs-platform/lib/es6/queue.js";
import * as $$Option from "bs-platform/lib/es6/option.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as StringMap from "./StringMap.js";
import * as Pinc_Lexer from "./Pinc_Lexer.js";
import * as Pinc_Token from "./Pinc_Token.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Pinc_Position from "./Pinc_Position.js";
import * as Pinc_Operators from "./Pinc_Operators.js";
import * as Pinc_Diagnostics from "./Pinc_Diagnostics.js";

function get_next_token(t) {
  var token = Queue.take_opt(t.next);
  if (token !== undefined) {
    return token;
  } else {
    return Pinc_Lexer.scan(t.lexer);
  }
}

function next(t) {
  while(true) {
    var token = get_next_token(t);
    var match = token.typ;
    if (typeof match !== "number") {
      t.token = token;
      return ;
    }
    if (match) {
      t.token = token;
      return ;
    }
    continue ;
  };
}

function peek(t) {
  while(true) {
    var token = get_next_token(t);
    var typ = token.typ;
    if (typeof typ === "number") {
      if (typ) {
        Queue.add(token, t.next);
        return typ;
      }
      continue ;
    }
    Queue.add(token, t.next);
    return typ;
  };
}

function optional(token, t) {
  var test = Caml_obj.caml_equal(t.token.typ, token);
  if (test) {
    next(t);
  }
  return test;
}

function expect(token, t) {
  var test = Caml_obj.caml_equal(t.token.typ, token);
  if (test) {
    return next(t);
  } else {
    return Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                TAG: /* Message */6,
                _0: "Expected: `" + (Pinc_Token.to_string(token) + ("`, got `" + (Pinc_Token.to_string(t.token.typ) + "`")))
              });
  }
}

function make(filename, src) {
  var lexer = Pinc_Lexer.make(filename, src);
  var initial_pos = Pinc_Position.make(filename, 0, 0);
  var initial_token = Pinc_Token.make(initial_pos, initial_pos, /* END_OF_INPUT */62);
  var t = {
    lexer: lexer,
    token: initial_token,
    next: Queue.create(undefined)
  };
  next(t);
  return t;
}

function expect_identifier(typOpt, t) {
  var typ = typOpt !== undefined ? typOpt : "All";
  var start_pos = Pinc_Lexer.make_position(t.lexer);
  var i = t.token.typ;
  if (typeof i !== "number") {
    switch (i.TAG | 0) {
      case /* IDENT_LOWER */0 :
          if (Caml_obj.caml_equal(typ, "Lower") || Caml_obj.caml_equal(typ, "All")) {
            next(t);
            return i._0;
          }
          break;
      case /* IDENT_UPPER */1 :
          if (Caml_obj.caml_equal(typ, "Upper") || Caml_obj.caml_equal(typ, "All")) {
            next(t);
            return i._0;
          }
          break;
      default:
        
    }
  }
  if (Caml_obj.caml_equal(typ, "Lower")) {
    return Pinc_Diagnostics.report(start_pos, Pinc_Lexer.make_position(t.lexer), {
                TAG: /* ExpectedLowerIdent */4,
                _0: i
              });
  } else if (Caml_obj.caml_equal(typ, "Upper")) {
    return Pinc_Diagnostics.report(start_pos, Pinc_Lexer.make_position(t.lexer), {
                TAG: /* ExpectedUpperIdent */3,
                _0: i
              });
  } else {
    return Pinc_Diagnostics.report(start_pos, Pinc_Lexer.make_position(t.lexer), {
                TAG: /* ExpectedIdent */2,
                _0: i
              });
  }
}

function separated_list(sep, fn, t) {
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var has_sep = optional(sep, t);
    var r = Curry._1(fn, t);
    if (r === undefined) {
      return List.rev(acc);
    }
    if (!(has_sep || Caml_obj.caml_equal(acc, /* [] */0))) {
      return Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                  TAG: /* Message */6,
                  _0: "Expected list to be separated by `" + (Pinc_Token.to_string(sep) + "`")
                });
    }
    _acc = {
      hd: Caml_option.valFromOption(r),
      tl: acc
    };
    continue ;
  };
}

function list(fn, t) {
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var r = Curry._1(fn, t);
    if (r === undefined) {
      return List.rev(acc);
    }
    _acc = {
      hd: Caml_option.valFromOption(r),
      tl: acc
    };
    continue ;
  };
}

function parse_string_template(t) {
  var s = t.token.typ;
  if (typeof s === "number") {
    if (s !== /* LEFT_PIPE_BRACE */7) {
      return ;
    }
    next(t);
    return $$Option.bind(parse_expression(undefined, t), (function (expression) {
                  expect(/* RIGHT_PIPE_BRACE */8, t);
                  return {
                          TAG: /* StringInterpolation */0,
                          _0: expression
                        };
                }));
  } else {
    if (s.TAG !== /* STRING */4) {
      return ;
    }
    next(t);
    return {
            TAG: /* StringText */1,
            _0: s._0
          };
  }
}

function parse_binary_operator(t) {
  var match = t.token.typ;
  if (typeof match !== "number") {
    return ;
  }
  switch (match) {
    case /* LEFT_PAREN */1 :
        return Pinc_Operators.Binary.make(/* FUNCTION_CALL */17);
    case /* LEFT_BRACK */3 :
        return Pinc_Operators.Binary.make(/* BRACKET_ACCESS */16);
    case /* DOT */14 :
        return Pinc_Operators.Binary.make(/* DOT_ACCESS */15);
    case /* DOTDOT */15 :
        return Pinc_Operators.Binary.make(/* RANGE */21);
    case /* DOTDOTDOT */16 :
        return Pinc_Operators.Binary.make(/* INCLUSIVE_RANGE */22);
    case /* ARROW_LEFT */18 :
        return Pinc_Operators.Binary.make(/* ARRAY_ADD */19);
    case /* PIPE */19 :
        return Pinc_Operators.Binary.make(/* PIPE */18);
    case /* ATAT */20 :
        return Pinc_Operators.Binary.make(/* MERGE */20);
    case /* GREATER */25 :
        return Pinc_Operators.Binary.make(/* GREATER */2);
    case /* LESS */26 :
        return Pinc_Operators.Binary.make(/* LESS */4);
    case /* PLUS */27 :
        return Pinc_Operators.Binary.make(/* PLUS */6);
    case /* MINUS */29 :
        return Pinc_Operators.Binary.make(/* MINUS */7);
    case /* STAR */30 :
        return Pinc_Operators.Binary.make(/* TIMES */8);
    case /* STAR_STAR */31 :
        return Pinc_Operators.Binary.make(/* POW */10);
    case /* SLASH */32 :
        return Pinc_Operators.Binary.make(/* DIV */9);
    case /* PERCENT */33 :
        return Pinc_Operators.Binary.make(/* MODULO */11);
    case /* LOGICAL_AND */34 :
        return Pinc_Operators.Binary.make(/* AND */13);
    case /* LOGICAL_OR */35 :
        return Pinc_Operators.Binary.make(/* OR */14);
    case /* NOT_EQUAL */36 :
        return Pinc_Operators.Binary.make(/* NOT_EQUAL */1);
    case /* EQUAL_EQUAL */37 :
        return Pinc_Operators.Binary.make(/* EQUAL */0);
    case /* GREATER_EQUAL */38 :
        return Pinc_Operators.Binary.make(/* GREATER_EQUAL */3);
    case /* LESS_EQUAL */39 :
        return Pinc_Operators.Binary.make(/* LESS_EQUAL */5);
    case /* PLUSPLUS */40 :
        return Pinc_Operators.Binary.make(/* CONCAT */12);
    case /* COMMENT */0 :
    case /* RIGHT_PAREN */2 :
    case /* RIGHT_BRACK */4 :
    case /* LEFT_BRACE */5 :
    case /* RIGHT_BRACE */6 :
    case /* LEFT_PIPE_BRACE */7 :
    case /* RIGHT_PIPE_BRACE */8 :
    case /* DOUBLE_QUOTE */9 :
    case /* COLON */10 :
    case /* DOUBLE_COLON */11 :
    case /* COMMA */12 :
    case /* SEMICOLON */13 :
    case /* ARROW */17 :
    case /* QUESTIONMARK */21 :
    case /* EQUAL */22 :
    case /* COLON_EQUAL */23 :
    case /* NOT */24 :
    case /* UNARY_MINUS */28 :
    case /* KEYWORD_FN */41 :
    case /* KEYWORD_LET */42 :
    case /* KEYWORD_MUTABLE */43 :
    case /* KEYWORD_TRUE */44 :
    case /* KEYWORD_FALSE */45 :
    case /* KEYWORD_IF */46 :
    case /* KEYWORD_ELSE */47 :
    case /* KEYWORD_FOR */48 :
    case /* KEYWORD_IN */49 :
    case /* KEYWORD_REVERSE */50 :
    case /* KEYWORD_BREAK */51 :
    case /* KEYWORD_CONTINUE */52 :
    case /* KEYWORD_COMPONENT */53 :
    case /* KEYWORD_LIBRARY */54 :
    case /* KEYWORD_SITE */55 :
    case /* KEYWORD_PAGE */56 :
    case /* KEYWORD_STORE */57 :
    case /* HTML_OPEN_FRAGMENT */58 :
    case /* HTML_CLOSE_FRAGMENT */59 :
    case /* HTML_OR_COMPONENT_TAG_SELF_CLOSING */60 :
    case /* HTML_OR_COMPONENT_TAG_END */61 :
    case /* END_OF_INPUT */62 :
        return ;
    
  }
}

function parse_expression_part(t) {
  var name = t.token.typ;
  if (typeof name === "number") {
    switch (name) {
      case /* LEFT_PAREN */1 :
          next(t);
          var expr = parse_expression(undefined, t);
          expect(/* RIGHT_PAREN */2, t);
          return expr;
      case /* LEFT_BRACK */3 :
          next(t);
          var expressions = $$Array.of_list(separated_list(/* COMMA */12, (function (eta) {
                      return parse_expression(undefined, eta);
                    }), t));
          expect(/* RIGHT_BRACK */4, t);
          return {
                  TAG: /* Array */4,
                  _0: expressions
                };
      case /* LEFT_BRACE */5 :
          next(t);
          var match = t.token.typ;
          var is_record;
          if (typeof match === "number" || match.TAG !== /* IDENT_LOWER */0) {
            is_record = false;
          } else {
            var token = peek(t);
            is_record = Caml_obj.caml_equal(token, /* COLON */10) || Caml_obj.caml_equal(token, /* QUESTIONMARK */21);
          }
          if (is_record) {
            var attrs = Curry._1(StringMap.of_seq, List.to_seq(separated_list(/* COMMA */12, parse_record_field, t)));
            expect(/* RIGHT_BRACE */6, t);
            return {
                    TAG: /* Record */5,
                    _0: attrs
                  };
          }
          var statements = list(parse_statement, t);
          expect(/* RIGHT_BRACE */6, t);
          return {
                  TAG: /* BlockExpression */13,
                  _0: statements
                };
      case /* DOUBLE_QUOTE */9 :
          next(t);
          var s = list(parse_string_template, t);
          expect(/* DOUBLE_QUOTE */9, t);
          return {
                  TAG: /* String */0,
                  _0: s
                };
      case /* NOT */24 :
          next(t);
          var operator = Pinc_Operators.Unary.make(/* NOT */1);
          return $$Option.bind(parse_expression(operator.precedence, t), (function (argument) {
                        return {
                                TAG: /* UnaryExpression */15,
                                _0: /* NOT */1,
                                _1: argument
                              };
                      }));
      case /* UNARY_MINUS */28 :
          next(t);
          var operator$1 = Pinc_Operators.Unary.make(/* MINUS */0);
          return $$Option.bind(parse_expression(operator$1.precedence, t), (function (argument) {
                        return {
                                TAG: /* UnaryExpression */15,
                                _0: /* MINUS */0,
                                _1: argument
                              };
                      }));
      case /* KEYWORD_FN */41 :
          next(t);
          expect(/* LEFT_PAREN */1, t);
          var parameters = separated_list(/* COMMA */12, parse_fn_param, t);
          expect(/* RIGHT_PAREN */2, t);
          expect(/* ARROW */17, t);
          return $$Option.bind(parse_expression(undefined, t), (function (body) {
                        return {
                                TAG: /* Function */6,
                                _0: parameters,
                                _1: body
                              };
                      }));
      case /* KEYWORD_TRUE */44 :
          next(t);
          return {
                  TAG: /* Bool */3,
                  _0: true
                };
      case /* KEYWORD_FALSE */45 :
          next(t);
          return {
                  TAG: /* Bool */3,
                  _0: false
                };
      case /* KEYWORD_IF */46 :
          next(t);
          expect(/* LEFT_PAREN */1, t);
          return $$Option.bind(parse_expression(undefined, t), (function (condition) {
                        expect(/* RIGHT_PAREN */2, t);
                        return $$Option.bind(parse_statement(t), (function (consequent) {
                                      var alternate = optional(/* KEYWORD_ELSE */47, t) ? parse_statement(t) : undefined;
                                      return {
                                              TAG: /* ConditionalExpression */14,
                                              condition: condition,
                                              consequent: consequent,
                                              alternate: alternate
                                            };
                                    }));
                      }));
      case /* KEYWORD_FOR */48 :
          next(t);
          expect(/* LEFT_PAREN */1, t);
          var index_or_iterator = expect_identifier("Lower", t);
          var match$1;
          if (optional(/* COMMA */12, t)) {
            var identifier = expect_identifier("Lower", t);
            match$1 = [
              /* Lowercase_Id */{
                _0: index_or_iterator
              },
              identifier
            ];
          } else {
            match$1 = [
              undefined,
              index_or_iterator
            ];
          }
          var index = match$1[0];
          var iterator = /* Lowercase_Id */{
            _0: match$1[1]
          };
          expect(/* KEYWORD_IN */49, t);
          var reverse = optional(/* KEYWORD_REVERSE */50, t);
          return $$Option.bind(parse_expression(undefined, t), (function (expr1) {
                        expect(/* RIGHT_PAREN */2, t);
                        var body = parse_statement(t);
                        if (body !== undefined) {
                          return {
                                  TAG: /* ForInExpression */11,
                                  index: index,
                                  iterator: iterator,
                                  reverse: reverse,
                                  iterable: expr1,
                                  body: body
                                };
                        } else {
                          return Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                                      TAG: /* Message */6,
                                      _0: "Expected statement as body of for loop"
                                    });
                        }
                      }));
      case /* HTML_OPEN_FRAGMENT */58 :
          next(t);
          var template_nodes = list(parse_template_node, t);
          expect(/* HTML_CLOSE_FRAGMENT */59, t);
          return {
                  TAG: /* TemplateExpression */12,
                  _0: template_nodes
                };
      default:
        return ;
    }
  } else {
    switch (name.TAG | 0) {
      case /* IDENT_LOWER */0 :
          next(t);
          return {
                  TAG: /* LowercaseIdentifierExpression */9,
                  _0: /* Lowercase_Id */{
                    _0: name._0
                  }
                };
      case /* IDENT_UPPER */1 :
          next(t);
          return {
                  TAG: /* UppercaseIdentifierExpression */8,
                  _0: /* Uppercase_Id */{
                    _0: name._0
                  }
                };
      case /* INT */2 :
          next(t);
          return {
                  TAG: /* Int */1,
                  _0: name._0
                };
      case /* FLOAT */3 :
          next(t);
          return {
                  TAG: /* Float */2,
                  _0: name._0
                };
      case /* TAG */5 :
          next(t);
          var name$1 = name._0;
          var attributes;
          if (optional(/* LEFT_PAREN */1, t)) {
            var res = Curry._1(StringMap.of_seq, List.to_seq(separated_list(/* COMMA */12, (function (eta) {
                            return parse_attribute(undefined, eta);
                          }), t)));
            expect(/* RIGHT_PAREN */2, t);
            attributes = res;
          } else {
            attributes = StringMap.empty;
          }
          var transformer;
          if (optional(/* DOUBLE_COLON */11, t)) {
            var bind = expect_identifier("Lower", t);
            expect(/* ARROW */17, t);
            var expr$1 = parse_expression(undefined, t);
            var body = expr$1 !== undefined ? expr$1 : Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                    TAG: /* Message */6,
                    _0: "Expected expression as transformer of tag"
                  });
            transformer = [
              /* Lowercase_Id */{
                _0: bind
              },
              body
            ];
          } else {
            transformer = undefined;
          }
          return {
                  TAG: /* TagExpression */10,
                  _0: {
                    tag_name: name$1,
                    attributes: attributes,
                    transformer: transformer
                  }
                };
      case /* HTML_OPEN_TAG */6 :
      case /* COMPONENT_OPEN_TAG */8 :
          break;
      default:
        return ;
    }
  }
  var template_nodes$1 = list(parse_template_node, t);
  return {
          TAG: /* TemplateExpression */12,
          _0: template_nodes$1
        };
}

function parse_expression(prioOpt, t) {
  var prio = prioOpt !== undefined ? prioOpt : -999;
  var loop = function (prio, _left, t) {
    while(true) {
      var left = _left;
      var match = parse_binary_operator(t);
      if (match === undefined) {
        return left;
      }
      var operator = match.typ;
      if (match.precedence < prio) {
        return left;
      }
      if (operator !== 17) {
        var precedence = match.precedence;
        next(t);
        var new_prio = match.assoc ? precedence : precedence + 1 | 0;
        var right = parse_expression(new_prio, t);
        if (right === undefined) {
          return Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                      TAG: /* Message */6,
                      _0: "Expected expression on right hand side of `" + (Pinc_Operators.Binary.to_string(operator) + "`")
                    });
        }
        var left$1 = {
          TAG: /* BinaryExpression */16,
          _0: left,
          _1: operator,
          _2: right
        };
        var expect_close = function (token) {
          return expect(token, t);
        };
        $$Option.iter(expect_close, match.closing_token);
        _left = left$1;
        continue ;
      }
      next(t);
      var $$arguments = separated_list(/* COMMA */12, (function (eta) {
              return parse_expression(undefined, eta);
            }), t);
      var left$2 = {
        TAG: /* FunctionCall */7,
        _0: left,
        _1: $$arguments
      };
      var expect_close$1 = function (token) {
        return expect(token, t);
      };
      $$Option.iter(expect_close$1, match.closing_token);
      _left = left$2;
      continue ;
    };
  };
  return $$Option.bind(parse_expression_part(t), (function (left) {
                return loop(prio, left, t);
              }));
}

function parse_attribute(sepOpt, t) {
  var sep = sepOpt !== undefined ? sepOpt : /* COLON */10;
  var key = t.token.typ;
  if (typeof key === "number") {
    return ;
  }
  if (key.TAG !== /* IDENT_LOWER */0) {
    return ;
  }
  var key$1 = key._0;
  next(t);
  expect(sep, t);
  var value = parse_expression(undefined, t);
  return $$Option.map((function (value) {
                return [
                        key$1,
                        value
                      ];
              }), value);
}

function parse_template_node(t) {
  var s = t.token.typ;
  if (typeof s === "number") {
    if (s !== /* LEFT_BRACE */5) {
      return ;
    }
    next(t);
    var e = parse_expression(undefined, t);
    var expression = e !== undefined ? ({
          TAG: /* ExpressionTemplateNode */2,
          _0: e
        }) : ({
          TAG: /* ExpressionTemplateNode */2,
          _0: {
            TAG: /* BlockExpression */13,
            _0: /* [] */0
          }
        });
    expect(/* RIGHT_BRACE */6, t);
    return expression;
  } else {
    switch (s.TAG | 0) {
      case /* STRING */4 :
          next(t);
          return {
                  TAG: /* TextTemplateNode */3,
                  _0: s._0
                };
      case /* HTML_OPEN_TAG */6 :
          var tag = s._0;
          next(t);
          var partial_arg = /* EQUAL */22;
          var attributes = Curry._1(StringMap.of_seq, List.to_seq(list((function (param) {
                          return parse_attribute(partial_arg, param);
                        }), t)));
          var self_closing = optional(/* HTML_OR_COMPONENT_TAG_SELF_CLOSING */60, t);
          var children;
          if (self_closing) {
            children = /* [] */0;
          } else {
            expect(/* HTML_OR_COMPONENT_TAG_END */61, t);
            var children$1 = list(parse_template_node, t);
            expect({
                  TAG: /* HTML_CLOSE_TAG */7,
                  _0: tag
                }, t);
            children = children$1;
          }
          return {
                  TAG: /* HtmlTemplateNode */0,
                  tag: tag,
                  attributes: attributes,
                  children: children,
                  self_closing: self_closing
                };
      case /* COMPONENT_OPEN_TAG */8 :
          var identifier = s._0;
          next(t);
          var partial_arg$1 = /* EQUAL */22;
          var attributes$1 = Curry._1(StringMap.of_seq, List.to_seq(list((function (param) {
                          return parse_attribute(partial_arg$1, param);
                        }), t)));
          var self_closing$1 = optional(/* HTML_OR_COMPONENT_TAG_SELF_CLOSING */60, t);
          var children$2;
          if (self_closing$1) {
            children$2 = /* [] */0;
          } else {
            expect(/* HTML_OR_COMPONENT_TAG_END */61, t);
            var children$3 = list(parse_template_node, t);
            expect({
                  TAG: /* COMPONENT_CLOSE_TAG */9,
                  _0: identifier
                }, t);
            children$2 = children$3;
          }
          return {
                  TAG: /* ComponentTemplateNode */1,
                  identifier: /* Uppercase_Id */{
                    _0: identifier
                  },
                  attributes: attributes$1,
                  children: children$2
                };
      default:
        return ;
    }
  }
}

function parse_fn_param(t) {
  var key = t.token.typ;
  if (typeof key === "number") {
    return ;
  }
  if (key.TAG !== /* IDENT_LOWER */0) {
    return ;
  }
  next(t);
  return key._0;
}

function parse_statement(t) {
  var identifier = t.token.typ;
  if (typeof identifier === "number") {
    switch (identifier) {
      case /* KEYWORD_LET */42 :
          next(t);
          var is_mutable = optional(/* KEYWORD_MUTABLE */43, t);
          var identifier$1 = expect_identifier("Lower", t);
          var is_nullable = optional(/* QUESTIONMARK */21, t);
          expect(/* EQUAL */22, t);
          var expression = parse_expression(undefined, t);
          optional(/* SEMICOLON */13, t);
          var exit = 0;
          if (is_mutable) {
            if (is_nullable) {
              if (expression !== undefined) {
                return {
                        TAG: /* OptionalMutableLetStatement */0,
                        _0: /* Lowercase_Id */{
                          _0: identifier$1
                        },
                        _1: expression
                      };
              }
              exit = 2;
            } else {
              if (expression !== undefined) {
                return {
                        TAG: /* MutableLetStatement */2,
                        _0: /* Lowercase_Id */{
                          _0: identifier$1
                        },
                        _1: expression
                      };
              }
              exit = 2;
            }
          } else if (is_nullable) {
            if (expression !== undefined) {
              return {
                      TAG: /* OptionalLetStatement */1,
                      _0: /* Lowercase_Id */{
                        _0: identifier$1
                      },
                      _1: expression
                    };
            }
            exit = 2;
          } else {
            if (expression !== undefined) {
              return {
                      TAG: /* LetStatement */3,
                      _0: /* Lowercase_Id */{
                        _0: identifier$1
                      },
                      _1: expression
                    };
            }
            exit = 2;
          }
          if (exit === 2) {
            return Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                        TAG: /* Message */6,
                        _0: "Expected expression as right hand side of let declaration"
                      });
          }
          break;
      case /* KEYWORD_BREAK */51 :
          next(t);
          optional(/* SEMICOLON */13, t);
          return /* BreakStatement */0;
      case /* KEYWORD_CONTINUE */52 :
          next(t);
          optional(/* SEMICOLON */13, t);
          return /* ContinueStatement */1;
      default:
        
    }
  } else if (identifier.TAG === /* IDENT_LOWER */0 && Caml_obj.caml_equal(peek(t), /* COLON_EQUAL */23)) {
    next(t);
    next(t);
    var expression$1 = parse_expression(undefined, t);
    var expression$2 = expression$1 !== undefined ? expression$1 : Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
            TAG: /* Message */6,
            _0: "Expected expression as right hand side of mutation statement"
          });
    optional(/* SEMICOLON */13, t);
    return {
            TAG: /* MutationStatement */4,
            _0: /* Lowercase_Id */{
              _0: identifier._0
            },
            _1: expression$2
          };
  }
  var expr = parse_expression(undefined, t);
  optional(/* SEMICOLON */13, t);
  return $$Option.map((function (expression) {
                return {
                        TAG: /* ExpressionStatement */5,
                        _0: expression
                      };
              }), expr);
}

function parse_record_field(t) {
  var key = t.token.typ;
  if (typeof key === "number") {
    return ;
  }
  if (key.TAG !== /* IDENT_LOWER */0) {
    return ;
  }
  var key$1 = key._0;
  next(t);
  var nullable = optional(/* QUESTIONMARK */21, t);
  expect(/* COLON */10, t);
  var value = parse_expression(undefined, t);
  return $$Option.map((function (value) {
                return [
                        key$1,
                        [
                          nullable,
                          value
                        ]
                      ];
              }), value);
}

function parse_declaration(t) {
  var typ = t.token.typ;
  if (typeof typ === "number") {
    if (typ >= 58) {
      if (typ >= 62) {
        return ;
      }
      
    } else if (typ >= 53) {
      next(t);
      var identifier = expect_identifier("Upper", t);
      var attributes;
      if (optional(/* LEFT_PAREN */1, t)) {
        var attributes$1 = Curry._1(StringMap.of_seq, List.to_seq(separated_list(/* COMMA */12, (function (eta) {
                        return parse_attribute(undefined, eta);
                      }), t)));
        expect(/* RIGHT_PAREN */2, t);
        attributes = Caml_option.some(attributes$1);
      } else {
        attributes = undefined;
      }
      var body = parse_expression(undefined, t);
      if (body === undefined) {
        return Pinc_Diagnostics.report(t.token.start_pos, t.token.end_pos, {
                    TAG: /* Message */6,
                    _0: "Expected declaration to have a body"
                  });
      }
      var exit = 0;
      if (typeof typ === "number" && typ >= 53) {
        switch (typ) {
          case /* KEYWORD_COMPONENT */53 :
              return [
                      identifier,
                      {
                        TAG: /* ComponentDeclaration */0,
                        _0: attributes,
                        _1: body
                      }
                    ];
          case /* KEYWORD_LIBRARY */54 :
              return [
                      identifier,
                      {
                        TAG: /* LibraryDeclaration */1,
                        _0: attributes,
                        _1: body
                      }
                    ];
          case /* KEYWORD_SITE */55 :
              return [
                      identifier,
                      {
                        TAG: /* SiteDeclaration */2,
                        _0: attributes,
                        _1: body
                      }
                    ];
          case /* KEYWORD_PAGE */56 :
              return [
                      identifier,
                      {
                        TAG: /* PageDeclaration */3,
                        _0: attributes,
                        _1: body
                      }
                    ];
          case /* KEYWORD_STORE */57 :
              return [
                      identifier,
                      {
                        TAG: /* StoreDeclaration */4,
                        _0: attributes,
                        _1: body
                      }
                    ];
          case /* HTML_OPEN_FRAGMENT */58 :
          case /* HTML_CLOSE_FRAGMENT */59 :
          case /* HTML_OR_COMPONENT_TAG_SELF_CLOSING */60 :
          case /* HTML_OR_COMPONENT_TAG_END */61 :
          case /* END_OF_INPUT */62 :
              exit = 2;
              break;
          
        }
      } else {
        exit = 2;
      }
      if (exit === 2) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Pinc_Parser.ml",
                552,
                15
              ],
              Error: new Error()
            };
      }
      
    }
    
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Pinc_Parser.ml",
          554,
          11
        ],
        Error: new Error()
      };
}

function parse(filename, source) {
  var t = make(filename, source);
  return Curry._1(StringMap.of_seq, List.to_seq(list(parse_declaration, t)));
}

export {
  make ,
  parse ,
}
/* StringMap Not a pure module */
