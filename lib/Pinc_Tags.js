// Generated by Melange

import * as Int from "bs-platform/lib/es6/int.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Either from "bs-platform/lib/es6/either.js";
import * as $$Option from "bs-platform/lib/es6/option.js";
import * as Result from "bs-platform/lib/es6/result.js";
import * as Stdlib from "bs-platform/lib/es6/stdlib.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Hashtbl from "bs-platform/lib/es6/hashtbl.js";
import * as StringMap from "./StringMap.js";

function make($$eval, validate, transform, get_value) {
  return {
          validate: validate,
          transform: transform,
          get_value: get_value,
          eval: $$eval
        };
}

function transform(info, value) {
  return Curry._1(info[3], value);
}

function validate(_info, value) {
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.ok(value);
    case /* Int */1 :
        return Result.error("tried to assign integer value to a string tag.");
    case /* Float */2 :
        return Result.error("tried to assign float value to a string tag.");
    case /* Bool */3 :
        return Result.error("tried to assign boolean value to a string tag.");
    case /* Array */4 :
        return Result.error("tried to assign array value to a string tag.");
    case /* Record */5 :
        return Result.error("tried to assign record value to a string tag.");
    case /* Function */6 :
        return Result.error("tried to assign function to a string tag.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to a string tag.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to a string tag.");
    
  }
}

function get_value(state, key) {
  var match = state.parent_component;
  if (match !== undefined) {
    return Curry._2(StringMap.find_opt, key, match[1]);
  } else {
    return Stdlib.failwith("#String is not implemented!");
  }
}

function $$eval(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "key", attributes);
  var key = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `key` #String to be of type string") : param._0
    ) : Stdlib.failwith("Expected attribute `key` to exist on #String");
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, key);
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0)));
}

var string = {
  validate: validate,
  transform: transform,
  get_value: get_value,
  eval: $$eval
};

function validate$1(_info, value) {
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.error("tried to assign string value to a int tag.");
    case /* Int */1 :
        return Result.ok(value);
    case /* Float */2 :
        return Result.error("tried to assign float value to a int tag.");
    case /* Bool */3 :
        return Result.error("tried to assign boolean value to a int tag.");
    case /* Array */4 :
        return Result.error("tried to assign array value to a int tag.");
    case /* Record */5 :
        return Result.error("tried to assign record value to a int tag.");
    case /* Function */6 :
        return Result.error("tried to assign function to a int tag.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to a int tag.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to a int tag.");
    
  }
}

function get_value$1(state, key) {
  var match = state.parent_component;
  if (match !== undefined) {
    return Curry._2(StringMap.find_opt, key, match[1]);
  } else {
    return Stdlib.failwith("#Int is not implemented!");
  }
}

function $$eval$1(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "key", attributes);
  var key = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `key` #Int to be of type string") : param._0
    ) : Stdlib.failwith("Expected attribute `key` to exist on #Int");
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, key);
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0)));
}

var $$int = {
  validate: validate$1,
  transform: transform,
  get_value: get_value$1,
  eval: $$eval$1
};

function validate$2(_info, value) {
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.error("tried to assign string value to a float tag.");
    case /* Int */1 :
        return Result.error("tried to assign int value to a float tag.");
    case /* Float */2 :
        return Result.ok(value);
    case /* Bool */3 :
        return Result.error("tried to assign boolean value to a float tag.");
    case /* Array */4 :
        return Result.error("tried to assign array value to a float tag.");
    case /* Record */5 :
        return Result.error("tried to assign record value to a float tag.");
    case /* Function */6 :
        return Result.error("tried to assign function to a float tag.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to a float tag.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to a float tag.");
    
  }
}

function get_value$2(state, key) {
  var match = state.parent_component;
  if (match !== undefined) {
    return Curry._2(StringMap.find_opt, key, match[1]);
  } else {
    return Stdlib.failwith("#Float is not implemented!");
  }
}

function $$eval$2(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "key", attributes);
  var key = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `key` #Float to be of type string") : param._0
    ) : Stdlib.failwith("Expected attribute `key` to exist on #Float");
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, key);
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0)));
}

var $$float = {
  validate: validate$2,
  transform: transform,
  get_value: get_value$2,
  eval: $$eval$2
};

function validate$3(_info, value) {
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.error("tried to assign string value to a boolean tag.");
    case /* Int */1 :
        return Result.error("tried to assign int value to a boolean tag.");
    case /* Float */2 :
        return Result.error("tried to assign float value to a boolean tag.");
    case /* Bool */3 :
        return Result.ok(value);
    case /* Array */4 :
        return Result.error("tried to assign array value to a boolean tag.");
    case /* Record */5 :
        return Result.error("tried to assign record value to a boolean tag.");
    case /* Function */6 :
        return Result.error("tried to assign function to a boolean tag.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to a boolean tag.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to a boolean tag.");
    
  }
}

function get_value$3(state, key) {
  var match = state.parent_component;
  if (match !== undefined) {
    return Curry._2(StringMap.find_opt, key, match[1]);
  } else {
    return Stdlib.failwith("#Boolean is not implemented!");
  }
}

function $$eval$3(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "key", attributes);
  var key = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `key` #Boolean to be of type string") : param._0
    ) : Stdlib.failwith("Expected attribute `key` to exist on #Boolean");
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, key);
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0)));
}

var $$boolean = {
  validate: validate$3,
  transform: transform,
  get_value: get_value$3,
  eval: $$eval$3
};

function validate$4(_info, value) {
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.error("tried to assign string value to a array tag.");
    case /* Int */1 :
        return Result.error("tried to assign int value to a array tag.");
    case /* Float */2 :
        return Result.error("tried to assign float value to a array tag.");
    case /* Bool */3 :
        return Result.error("tried to assign boolean value to a array tag.");
    case /* Array */4 :
        return Result.ok(value);
    case /* Record */5 :
        return Result.error("tried to assign record value to a array tag.");
    case /* Function */6 :
        return Result.error("tried to assign function to a array tag.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to a array tag.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to a array tag.");
    
  }
}

function get_value$4(state, key) {
  var match = state.parent_component;
  if (match !== undefined) {
    return Curry._2(StringMap.find_opt, key, match[1]);
  } else {
    return Stdlib.failwith("#Array is not implemented!");
  }
}

function $$eval$4(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "key", attributes);
  var key = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `key` #Array to be of type string") : param._0
    ) : Stdlib.failwith("Expected attribute `key` to exist on #Array");
  var param$1 = Curry._2(StringMap.find_opt, "of", attributes);
  var of_info = param$1 !== undefined ? (
      typeof param$1 === "number" || param$1.TAG !== /* TagInfo */8 ? Stdlib.failwith("Expected attribute `of` #Array to be a tag describing the type of the items inside.") : param$1._0
    ) : Stdlib.failwith("Expected attribute `of` to exist on #Array");
  var of_name = "#" + of_info[0];
  var handler = Curry._2(StringMap.find_opt, of_name, state.tag_listeners);
  var of_handler = handler !== undefined ? handler : Stdlib.failwith("No tag handler for `" + (of_name + "` was provided."));
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, key);
  var validated_data = Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0));
  return Result.map(Curry._1(self.transform, info), Result.bind(validated_data, (function (a) {
                    if (typeof a === "number") {
                      return Result.ok(/* Null */0);
                    }
                    if (a.TAG !== /* Array */4) {
                      return Stdlib.failwith("tried to assign non array value to array tag.");
                    }
                    var loop = function (_acc, _list) {
                      while(true) {
                        var list = _list;
                        var acc = _acc;
                        if (acc.TAG !== /* Ok */0) {
                          return Result.error(acc._0);
                        }
                        if (!list) {
                          return acc;
                        }
                        var v = Result.map(Curry._1(of_handler.transform, of_info), Curry._2(of_handler.validate, of_info, list.hd));
                        if (v.TAG !== /* Ok */0) {
                          return Result.error(v._0);
                        }
                        var acc$1 = Result.ok({
                              hd: v._0,
                              tl: acc._0
                            });
                        _list = list.tl;
                        _acc = acc$1;
                        continue ;
                      };
                    };
                    return Result.map((function (a) {
                                  return {
                                          TAG: /* Array */4,
                                          _0: a
                                        };
                                }), Result.map($$Array.of_list, Result.map(List.rev, loop(Result.ok(/* [] */0), $$Array.to_list(a._0)))));
                  })));
}

var array = {
  validate: validate$4,
  transform: transform,
  get_value: get_value$4,
  eval: $$eval$4
};

function validate$5(_info, value) {
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.error("tried to assign string value to a record tag.");
    case /* Int */1 :
        return Result.error("tried to assign int value to a record tag.");
    case /* Float */2 :
        return Result.error("tried to assign float value to a record tag.");
    case /* Bool */3 :
        return Result.error("tried to assign boolean value to a record tag.");
    case /* Array */4 :
        return Result.error("tried to assign array value to a record tag.");
    case /* Record */5 :
        return Result.ok(value);
    case /* Function */6 :
        return Result.error("tried to assign function to a record tag.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to a record tag.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to a record tag.");
    
  }
}

function get_value$5(state, key) {
  var match = state.parent_component;
  if (match !== undefined) {
    return Curry._2(StringMap.find_opt, key, match[1]);
  } else {
    return Stdlib.failwith("#Record is not implemented!");
  }
}

function $$eval$5(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "key", attributes);
  var key = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `key` #Record to be of type string") : param._0
    ) : Stdlib.failwith("Expected attribute `key` to exist on #Record");
  var param$1 = Curry._2(StringMap.find_opt, "of", attributes);
  var of$p = param$1 !== undefined ? (
      typeof param$1 === "number" || param$1.TAG !== /* Record */5 ? Stdlib.failwith("Expected attribute `of` #Array to be a tag describing the type of the items inside.") : Curry._2(StringMap.filter_map, (function (_key, i) {
                if (typeof i === "number" || i.TAG !== /* TagInfo */8) {
                  return ;
                } else {
                  return i._0;
                }
              }), param$1._0)
    ) : Stdlib.failwith("Expected attribute `of` to exist on #Record");
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, key);
  return Result.map(Curry._1(self.transform, info), Result.map((function (r) {
                    if (typeof r === "number") {
                      return /* Null */0;
                    } else if (r.TAG === /* Record */5) {
                      return {
                              TAG: /* Record */5,
                              _0: Curry._2(StringMap.mapi, (function (key, value) {
                                      var of_info = Curry._2(StringMap.find_opt, key, of$p);
                                      if (of_info === undefined) {
                                        return value;
                                      }
                                      var of_name = "#" + of_info[0];
                                      var handler = Curry._2(StringMap.find_opt, of_name, state.tag_listeners);
                                      var of_handler = handler !== undefined ? handler : Stdlib.failwith("No tag handler for `" + (of_name + "` was provided."));
                                      var e = Curry._2(of_handler.validate, of_info, value);
                                      if (e.TAG === /* Ok */0) {
                                        return Curry._2(of_handler.transform, of_info, e._0);
                                      } else {
                                        return Stdlib.failwith(e._0);
                                      }
                                    }), r._0)
                            };
                    } else {
                      return Stdlib.failwith("Tried to assign non record value to a record tag.");
                    }
                  }), Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0))));
}

var record = {
  validate: validate$5,
  transform: transform,
  get_value: get_value$5,
  eval: $$eval$5
};

function validate$6(info, value) {
  var attributes = info[2];
  var i = $$Option.value(Curry._2(StringMap.find_opt, "min", attributes), {
        TAG: /* Int */1,
        _0: 0
      });
  var min;
  min = typeof i === "number" || i.TAG !== /* Int */1 ? Stdlib.failwith("Expected attribute `min` on #Slot to be of type int.") : i._0;
  var param = Curry._2(StringMap.find_opt, "max", attributes);
  var max = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* Int */1 ? Stdlib.failwith("Expected attribute `max` on #Slot to be of type int.") : param._0
    ) : Int.max_int;
  var param$1 = Curry._2(StringMap.find_opt, "instanceOf", attributes);
  var instanceOf = param$1 !== undefined ? (
      typeof param$1 === "number" || param$1.TAG !== /* Array */4 ? Stdlib.failwith("Expected attribute `instanceOf` on #Slot to be an array.") : $$Array.map((function (info) {
                if (typeof info === "number" || info.TAG !== /* DefinitionInfo */7) {
                  return Stdlib.failwith("Expected attribute `instanceOf` on #Slot to be an array of uppercase identifiers.");
                } else {
                  return info._0;
                }
              }), param$1._0)
    ) : undefined;
  if (typeof value === "number") {
    return Result.ok(value);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
        return Result.error("tried to assign string value to slot.");
    case /* Int */1 :
        return Result.error("tried to assign int value to slot.");
    case /* Float */2 :
        return Result.error("tried to assign float value to slot.");
    case /* Bool */3 :
        return Result.error("tried to assign boolean value to slot.");
    case /* Array */4 :
        var a = value._0;
        if (a.length < min) {
          return Result.error("#Slot did not reach the minimum amount of nodes (specified as " + (String(min) + ")."));
        }
        if (a.length < min) {
          return Result.error("#Slot did not reach the minimum amount of nodes (specified as " + (String(min) + ")."));
        }
        if (a.length > max) {
          return Result.error("#Slot includes more than the maximum amount of nodes (specified as " + (String(max) + ")."));
        }
        var check_instance_restriction = function (tag) {
          if (instanceOf === undefined) {
            return Result.ok(undefined);
          }
          var is_in_list = {
            contents: false
          };
          var match = List.partition_map((function (param) {
                  var name = param[0];
                  if (name === tag) {
                    is_in_list.contents = true;
                  }
                  if (param[2] === "Negated") {
                    return Either.right(name);
                  } else {
                    return Either.left(name);
                  }
                }), $$Array.to_list(instanceOf));
          var allowed = match[0];
          var is_in_list$1 = is_in_list.contents;
          var is_allowed = allowed ? (
              match[1] ? List.mem(tag, allowed) : is_in_list$1
            ) : !is_in_list$1;
          if (is_allowed) {
            return Result.ok(undefined);
          }
          var arg = [];
          return Result.error("Child with tag `" + (tag + ("` may not be used inside this #Slot . The following restrictions are set: [ " + ($$String.concat(",", List.map((function (param) {
                                      var name = param[0];
                                      if (param[2] === "Negated") {
                                        return "!" + name;
                                      } else {
                                        return name;
                                      }
                                    }), $$Array.to_list((function (param) {
                                            return $$Option.value(param, arg);
                                          })(instanceOf)))) + " ]"))));
        };
        var match = List.partition_map((function (v) {
                var tag;
                if (typeof v === "number") {
                  return Either.right("Tried to assign a non node value to a #Slot. Only nodes template nodes are allowed inside slots. If you want to put another value (like a string) into a slot, you have to wrap it in some node.");
                }
                switch (v.TAG | 0) {
                  case /* HtmlTemplateNode */9 :
                      tag = v._0;
                      break;
                  case /* ComponentTemplateNode */10 :
                      tag = v._1;
                      break;
                  default:
                    return Either.right("Tried to assign a non node value to a #Slot. Only nodes template nodes are allowed inside slots. If you want to put another value (like a string) into a slot, you have to wrap it in some node.");
                }
                var e = check_instance_restriction(tag);
                if (e.TAG === /* Ok */0) {
                  return Either.left(v);
                } else {
                  return Either.right(e._0);
                }
              }), $$Array.to_list(a));
        var failed = match[1];
        if (failed) {
          return Result.error(failed.hd);
        } else {
          return Result.ok({
                      TAG: /* Array */4,
                      _0: $$Array.of_list(match[0])
                    });
        }
    case /* Record */5 :
        return Result.error("tried to assign record value to slot.");
    case /* Function */6 :
        return Result.error("tried to assign function to slot.");
    case /* DefinitionInfo */7 :
        return Result.error("tried to assign definition info to slot.");
    case /* TagInfo */8 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("tried to assign template node to slot.");
    
  }
}

function get_value$6(state, key) {
  var find_slot_key = function (attributes) {
    var s = $$Option.value(Curry._2(StringMap.find_opt, "slot", attributes), {
          TAG: /* String */0,
          _0: ""
        });
    if (typeof s === "number" || s.TAG !== /* String */0) {
      return Stdlib.failwith("Expected slot attribute to be of type string");
    } else {
      return s._0;
    }
  };
  var keep_slotted = function (acc, l) {
    if (typeof l === "number") {
      return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
    }
    switch (l.TAG | 0) {
      case /* String */0 :
          if ($$String.trim(l._0) === "") {
            return acc;
          } else {
            return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
          }
      case /* Array */4 :
          return $$Array.fold_left(keep_slotted, acc, l._0);
      case /* HtmlTemplateNode */9 :
          var attributes = l._1;
          if (find_slot_key(attributes) === key) {
            return {
                    hd: {
                      TAG: /* HtmlTemplateNode */9,
                      _0: l._0,
                      _1: attributes,
                      _2: l._2,
                      _3: l._3
                    },
                    tl: acc
                  };
          } else {
            return acc;
          }
      case /* ComponentTemplateNode */10 :
          var attributes$1 = l._2;
          if (find_slot_key(attributes$1) === key) {
            return {
                    hd: {
                      TAG: /* ComponentTemplateNode */10,
                      _0: l._0,
                      _1: l._1,
                      _2: attributes$1
                    },
                    tl: acc
                  };
          } else {
            return acc;
          }
      default:
        return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
    }
  };
  var match = state.parent_component;
  if (match === undefined) {
    return Stdlib.failwith("#Slot is not implemented!");
  }
  var list = List.fold_left(keep_slotted, /* [] */0, match[2]);
  if (list) {
    return {
            TAG: /* Array */4,
            _0: $$Array.of_list(List.rev(list))
          };
  }
  
}

function $$eval$6(self, state, info) {
  var s = $$Option.value(Curry._2(StringMap.find_opt, "name", info[2]), {
        TAG: /* String */0,
        _0: ""
      });
  var slot_name;
  slot_name = typeof s === "number" || s.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `name` on #Slot to be of type string.") : s._0;
  var arg = {
    TAG: /* Array */4,
    _0: []
  };
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, (function (param) {
                      return $$Option.value(param, arg);
                    })(Curry._2(self.get_value, state, slot_name))));
}

var slot = {
  validate: validate$6,
  transform: transform,
  get_value: get_value$6,
  eval: $$eval$6
};

function validate$7(_info, value) {
  if (typeof value === "number") {
    return Result.ok(/* Null */0);
  }
  switch (value.TAG | 0) {
    case /* String */0 :
    case /* Int */1 :
    case /* Float */2 :
    case /* Bool */3 :
    case /* Array */4 :
    case /* Record */5 :
    case /* Function */6 :
    case /* DefinitionInfo */7 :
    case /* TagInfo */8 :
    case /* HtmlTemplateNode */9 :
    case /* ComponentTemplateNode */10 :
        return Result.error("Something unexpected happened...this is my fault, not yours");
    
  }
}

function get_value$7(_state, _key) {
  return /* Null */0;
}

function $$eval$7(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "name", attributes);
  var name = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `name` on #SetContext to be of type string.") : param._0
    ) : Stdlib.failwith("attribute name is required when setting a context.");
  var value = Curry._2(StringMap.find_opt, "value", attributes);
  var value$1 = value !== undefined ? value : Stdlib.failwith("attribute value is required when setting a context.");
  Hashtbl.add(state.context, name, value$1);
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, $$Option.value(Curry._2(self.get_value, state, name), /* Null */0)));
}

var set_context = {
  validate: validate$7,
  transform: transform,
  get_value: get_value$7,
  eval: $$eval$7
};

function validate$8(_info, value) {
  if (typeof value === "number" || value.TAG !== /* TagInfo */8) {
    return Result.ok(value);
  } else {
    return Result.error("Something unexpected happened...this is my fault, not yours");
  }
}

function get_value$8(state, key) {
  return Hashtbl.find_opt(state.context, key);
}

function $$eval$8(self, state, info) {
  var attributes = info[2];
  var param = Curry._2(StringMap.find_opt, "name", attributes);
  var name = param !== undefined ? (
      typeof param === "number" || param.TAG !== /* String */0 ? Stdlib.failwith("Expected attribute `name` on #GetContext to be of type string.") : param._0
    ) : Stdlib.failwith("attribute name is required when getting a context.");
  var $$default = Curry._2(StringMap.find_opt, "default", attributes);
  var v = Curry._2(self.get_value, state, name);
  return Result.map(Curry._1(self.transform, info), Curry._2(self.validate, info, $$Option.value(v !== undefined && typeof v !== "number" ? v : $$default, /* Null */0)));
}

var get_context = {
  validate: validate$8,
  transform: transform,
  get_value: get_value$8,
  eval: $$eval$8
};

var Default = {
  string: string,
  $$int: $$int,
  $$float: $$float,
  $$boolean: $$boolean,
  array: array,
  record: record,
  slot: slot,
  set_context: set_context,
  get_context: get_context
};

export {
  make ,
  Default ,
}
/* Hashtbl Not a pure module */
