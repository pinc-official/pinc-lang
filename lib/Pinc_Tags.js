// Generated by Melange

import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Either from "bs-platform/lib/es6/either.js";
import * as $$Option from "bs-platform/lib/es6/option.js";
import * as Result from "bs-platform/lib/es6/result.js";
import * as Stdlib from "bs-platform/lib/es6/stdlib.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Hashtbl from "bs-platform/lib/es6/hashtbl.js";
import * as StringMap from "./StringMap.js";

function transform(info, value) {
  return Curry._1(info[3], value);
}

function make_string(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to a string tag.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to a string tag.");
    } else if (variant === "Int") {
      return Result.error("tried to assign integer value to a string tag.");
    } else if (variant === "Float") {
      return Result.error("tried to assign float value to a string tag.");
    } else if (variant === "Bool") {
      return Result.error("tried to assign boolean value to a string tag.");
    } else if (variant === "Record") {
      return Result.error("tried to assign record value to a string tag.");
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to a string tag.");
    } else if (variant === "Array") {
      return Result.error("tried to assign array value to a string tag.");
    } else {
      return Result.ok(value);
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "key", attributes);
    var key = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #String to be of type string") : param.VAL
      ) : Stdlib.failwith("Expected attribute `key` to exist on #String");
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Curry._2(StringMap.find_opt, key, data);
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, $$Option.value(v !== undefined ? v : $$default, "Null")));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_int(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to a int tag.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to a int tag.");
    } else if (variant === "Int") {
      return Result.ok(value);
    } else if (variant === "Float") {
      return Result.error("tried to assign float value to a int tag.");
    } else if (variant === "Bool") {
      return Result.error("tried to assign boolean value to a int tag.");
    } else if (variant === "Record") {
      return Result.error("tried to assign record value to a int tag.");
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to a int tag.");
    } else if (variant === "Array") {
      return Result.error("tried to assign array value to a int tag.");
    } else {
      return Result.error("tried to assign string value to a int tag.");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "key", attributes);
    var key = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Int to be of type string") : param.VAL
      ) : Stdlib.failwith("Expected attribute `key` to exist on #Int");
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Curry._2(StringMap.find_opt, key, data);
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, $$Option.value(v !== undefined ? v : $$default, "Null")));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_float(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to a float tag.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to a float tag.");
    } else if (variant === "Int") {
      return Result.error("tried to assign int value to a float tag.");
    } else if (variant === "Float") {
      return Result.ok(value);
    } else if (variant === "Bool") {
      return Result.error("tried to assign boolean value to a float tag.");
    } else if (variant === "Record") {
      return Result.error("tried to assign record value to a float tag.");
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to a float tag.");
    } else if (variant === "Array") {
      return Result.error("tried to assign array value to a float tag.");
    } else {
      return Result.error("tried to assign string value to a float tag.");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "key", attributes);
    var key = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Float to be of type string") : param.VAL
      ) : Stdlib.failwith("Expected attribute `key` to exist on #Float");
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Curry._2(StringMap.find_opt, key, data);
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, $$Option.value(v !== undefined ? v : $$default, "Null")));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_boolean(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to a boolean tag.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to a boolean tag.");
    } else if (variant === "Int") {
      return Result.error("tried to assign int value to a boolean tag.");
    } else if (variant === "Float") {
      return Result.error("tried to assign float value to a boolean tag.");
    } else if (variant === "Bool") {
      return Result.ok(value);
    } else if (variant === "Record") {
      return Result.error("tried to assign record value to a boolean tag.");
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to a boolean tag.");
    } else if (variant === "Array") {
      return Result.error("tried to assign array value to a boolean tag.");
    } else {
      return Result.error("tried to assign string value to a boolean tag.");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "key", attributes);
    var key = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Boolean to be of type string") : param.VAL
      ) : Stdlib.failwith("Expected attribute `key` to exist on #Boolean");
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Curry._2(StringMap.find_opt, key, data);
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, $$Option.value(v !== undefined ? v : $$default, "Null")));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_array(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to a array tag.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to a array tag.");
    } else if (variant === "Int") {
      return Result.error("tried to assign int value to a array tag.");
    } else if (variant === "Float") {
      return Result.error("tried to assign float value to a array tag.");
    } else if (variant === "Bool") {
      return Result.error("tried to assign boolean value to a array tag.");
    } else if (variant === "Record") {
      return Result.error("tried to assign record value to a array tag.");
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to a array tag.");
    } else if (variant === "Array") {
      return Result.ok(value);
    } else {
      return Result.error("tried to assign string value to a array tag.");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "key", attributes);
    var key = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Array to be of type string") : param.VAL
      ) : Stdlib.failwith("Expected attribute `key` to exist on #Array");
    var param$1 = Curry._2(StringMap.find_opt, "of", attributes);
    var of_info = param$1 !== undefined ? (
        typeof param$1 === "string" || param$1.NAME !== "TagInfo" ? Stdlib.failwith("Expected attribute `of` #Array to be a tag describing the type of the items inside.") : param$1.VAL
      ) : Stdlib.failwith("Expected attribute `of` to exist on #Array");
    var of_handler = get_handler_for(of_info[0]);
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Curry._2(StringMap.find_opt, key, data);
    var validated_data = validate(info, $$Option.value(v !== undefined ? v : $$default, "Null"));
    return Result.map((function (param) {
                  return transform(info, param);
                }), Result.bind(validated_data, (function (param) {
                      if (typeof param === "string") {
                        return Result.ok("Null");
                      }
                      var loop = function (_acc, _list) {
                        while(true) {
                          var list = _list;
                          var acc = _acc;
                          if (acc.TAG !== /* Ok */0) {
                            return Result.error(acc._0);
                          }
                          if (!list) {
                            return acc;
                          }
                          var v = Result.map((function (param) {
                                  return transform(of_info, param);
                                }), Curry._2(of_handler.validate, of_info, list.hd));
                          if (v.TAG !== /* Ok */0) {
                            return Result.error(v._0);
                          }
                          var acc$1 = Result.ok({
                                hd: v._0,
                                tl: acc._0
                              });
                          _list = list.tl;
                          _acc = acc$1;
                          continue ;
                        };
                      };
                      return Result.map((function (a) {
                                    return {
                                            NAME: "Array",
                                            VAL: a
                                          };
                                  }), Result.map($$Array.of_list, Result.map(List.rev, loop(Result.ok(/* [] */0), $$Array.to_list(param.VAL)))));
                    })));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_record(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to a record tag.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to a record tag.");
    } else if (variant === "Int") {
      return Result.error("tried to assign int value to a record tag.");
    } else if (variant === "Float") {
      return Result.error("tried to assign float value to a record tag.");
    } else if (variant === "Bool") {
      return Result.error("tried to assign boolean value to a record tag.");
    } else if (variant === "Record") {
      return Result.ok(value);
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to a record tag.");
    } else if (variant === "Array") {
      return Result.error("tried to assign array value to a record tag.");
    } else {
      return Result.error("tried to assign string value to a record tag.");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "key", attributes);
    var key = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Record to be of type string") : param.VAL
      ) : Stdlib.failwith("Expected attribute `key` to exist on #Record");
    var param$1 = Curry._2(StringMap.find_opt, "of", attributes);
    var of$p = param$1 !== undefined ? (
        typeof param$1 === "string" || param$1.NAME !== "Record" ? Stdlib.failwith("Expected attribute `of` #Array to be a tag describing the type of the items inside.") : Curry._2(StringMap.filter_map, (function (_key, param) {
                  if (typeof param === "string" || param.NAME !== "TagInfo") {
                    return ;
                  } else {
                    return param.VAL;
                  }
                }), param$1.VAL)
      ) : Stdlib.failwith("Expected attribute `of` to exist on #Record");
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Curry._2(StringMap.find_opt, key, data);
    return Result.map((function (param) {
                  return transform(info, param);
                }), Result.map((function (param) {
                      if (typeof param === "string") {
                        return "Null";
                      } else {
                        return {
                                NAME: "Record",
                                VAL: Curry._2(StringMap.mapi, (function (key, value) {
                                        var info = Curry._2(StringMap.find_opt, key, of$p);
                                        if (info !== undefined) {
                                          return transform(info, value);
                                        } else {
                                          return value;
                                        }
                                      }), param.VAL)
                              };
                      }
                    }), validate(info, $$Option.value(v !== undefined ? v : $$default, "Null"))));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_slot(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok(value);
    }
    var variant = value.NAME;
    if (variant === "DefinitionInfo") {
      return Result.error("tried to assign definition info to slot.");
    } else if (variant === "TagInfo") {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    } else if (variant === "Function") {
      return Result.error("tried to assign function to slot.");
    } else if (variant === "Int") {
      return Result.error("tried to assign int value to slot.");
    } else if (variant === "Float") {
      return Result.error("tried to assign float value to slot.");
    } else if (variant === "Bool") {
      return Result.error("tried to assign boolean value to slot.");
    } else if (variant === "Record") {
      return Result.error("tried to assign record value to slot.");
    } else if (variant === "TemplateNode") {
      return Result.error("tried to assign template node to slot.");
    } else if (variant === "Array") {
      return Result.ok(value);
    } else {
      return Result.error("tried to assign string value to slot.");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = $$Option.value(Curry._2(StringMap.find_opt, "name", attributes), {
          NAME: "String",
          VAL: ""
        });
    var slot_name = typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `name` on #Slot to be of type string.") : param.VAL;
    var param$1 = $$Option.value(Curry._2(StringMap.find_opt, "min", attributes), {
          NAME: "Int",
          VAL: 0
        });
    var min = typeof param$1 === "string" || param$1.NAME !== "Int" ? Stdlib.failwith("Expected attribute `min` on #Slot to be of type int.") : param$1.VAL;
    var param$2 = Curry._2(StringMap.find_opt, "max", attributes);
    var max = param$2 !== undefined ? (
        typeof param$2 === "string" || param$2.NAME !== "Int" ? Stdlib.failwith("Expected attribute `max` on #Slot to be of type int.") : param$2.VAL
      ) : undefined;
    var param$3 = Curry._2(StringMap.find_opt, "instanceOf", attributes);
    var instanceOf = param$3 !== undefined ? (
        typeof param$3 === "string" || param$3.NAME !== "Array" ? Stdlib.failwith("Expected attribute `instanceOf` on #Slot to be an array.") : $$Array.map((function (param) {
                  if (typeof param === "string" || param.NAME !== "DefinitionInfo") {
                    return Stdlib.failwith("Expected attribute `instanceOf` on #Slot to be an array of uppercase identifiers.");
                  } else {
                    return param.VAL;
                  }
                }), param$3.VAL)
      ) : undefined;
    var find_slot_key = function (attributes) {
      var param = $$Option.value(Curry._2(StringMap.find_opt, "slot", attributes), {
            NAME: "String",
            VAL: ""
          });
      if (typeof param === "string" || param.NAME !== "String") {
        return Stdlib.failwith("Expected slot attribute to be of type string");
      } else {
        return param.VAL;
      }
    };
    var keep_slotted = function (acc, value) {
      var tag;
      var attributes;
      if (typeof value === "string") {
        return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
      }
      var variant = value.NAME;
      if (variant === "String") {
        if ($$String.trim(value.VAL) === "") {
          return acc;
        } else {
          return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
        }
      }
      if (variant !== "TemplateNode") {
        if (variant === "Array") {
          return $$Array.fold_left(keep_slotted, acc, value.VAL);
        } else {
          return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
        }
      }
      var match = value.VAL;
      var match$1 = match[0];
      if (typeof match$1 === "string") {
        if (match$1 !== "Html") {
          return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
        }
        tag = match[1];
        attributes = match[2];
      } else {
        if (match$1.NAME !== "Component") {
          return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
        }
        tag = match[1];
        attributes = match[2];
      }
      if (find_slot_key(attributes) === slot_name) {
        var f = $$Array.append(acc, [value]);
        if (instanceOf === undefined) {
          return f;
        }
        var is_in_list = {
          contents: false
        };
        var match$2 = List.partition_map((function (param) {
                var name = param[0];
                if (name === tag) {
                  is_in_list.contents = true;
                }
                if (param[2] === "Negated") {
                  return Either.right(name);
                } else {
                  return Either.left(name);
                }
              }), $$Array.to_list(instanceOf));
        var allowed = match$2[0];
        var is_in_list$1 = is_in_list.contents;
        var is_allowed = allowed ? (
            match$2[1] ? List.mem(tag, allowed) : is_in_list$1
          ) : !is_in_list$1;
        if (is_allowed) {
          return f;
        }
        var arg = [];
        return Stdlib.failwith("Child with tag `" + (tag + ("` may not be used inside the " + ((
                          slot_name === "" ? "Default #Slot." : "#Slot with name `" + (slot_name + "`")
                        ) + (". The following restrictions are set: [ " + ($$String.concat(",", List.map((function (param) {
                                        var name = param[0];
                                        if (param[2] === "Negated") {
                                          return "!" + name;
                                        } else {
                                          return name;
                                        }
                                      }), $$Array.to_list((function (param) {
                                              return $$Option.value(param, arg);
                                            })(instanceOf)))) + " ]"))))));
      } else {
        return acc;
      }
    };
    var slotted_children = $$Array.fold_left(keep_slotted, [], $$Array.of_list(data));
    var amount_of_children = slotted_children.length;
    var exit = 0;
    var exit$1 = 0;
    if (slot_name === "") {
      if (amount_of_children < min) {
        return Stdlib.failwith("Default #Slot did not reach the minimum amount of nodes (specified as " + (String(min) + ")."));
      }
      exit$1 = 3;
    } else {
      exit$1 = 3;
    }
    if (exit$1 === 3) {
      if (amount_of_children < min) {
        return Stdlib.failwith("#Slot with name `" + (slot_name + ("` did not reach the minimum amount of nodes (specified as " + (String(min) + ")."))));
      }
      if (slot_name === "") {
        if (max !== undefined) {
          if (amount_of_children > max) {
            return Stdlib.failwith("Default #Slot includes more than the maximum amount of nodes (specified as " + (String(max) + ")."));
          }
          exit = 2;
        }
        
      } else {
        exit = 2;
      }
    }
    if (exit === 2 && max !== undefined && amount_of_children > max) {
      return Stdlib.failwith("#Slot with name `" + (slot_name + ("` includes more than the maximum amount of nodes (specified as " + (String(max) + ")."))));
    }
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, {
                    NAME: "Array",
                    VAL: slotted_children
                  }));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_set_context(data) {
  var validate = function (_info, value) {
    if (typeof value === "string") {
      return Result.ok("Null");
    }
    return Result.error("Something unexpected happened...this is my fault, not yours");
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "name", attributes);
    var name = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `name` on #SetContext to be of type string.") : param.VAL
      ) : Stdlib.failwith("attribute name is required when setting a context.");
    var value = Curry._2(StringMap.find_opt, "value", attributes);
    var value$1 = value !== undefined ? value : Stdlib.failwith("attribute value is required when setting a context.");
    Hashtbl.add(data, name, value$1);
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, "Null"));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function make_get_context(data) {
  var validate = function (_info, value) {
    if (typeof value === "string" || value.NAME !== "TagInfo") {
      return Result.ok(value);
    } else {
      return Result.error("Something unexpected happened...this is my fault, not yours");
    }
  };
  var $$eval = function (info) {
    var attributes = info[2];
    var param = Curry._2(StringMap.find_opt, "name", attributes);
    var name = param !== undefined ? (
        typeof param === "string" || param.NAME !== "String" ? Stdlib.failwith("Expected attribute `name` on #GetContext to be of type string.") : param.VAL
      ) : Stdlib.failwith("attribute name is required when getting a context.");
    var $$default = Curry._2(StringMap.find_opt, "default", attributes);
    var v = Hashtbl.find_opt(data, name);
    return Result.map((function (param) {
                  return transform(info, param);
                }), validate(info, $$Option.value(v !== undefined ? v : $$default, "Null")));
  };
  return {
          validate: validate,
          transform: transform,
          eval: $$eval
        };
}

function get_handler_for(s) {
  switch (s) {
    case "Array" :
        return make_array(StringMap.empty);
    case "Boolean" :
        return make_boolean(StringMap.empty);
    case "Float" :
        return make_float(StringMap.empty);
    case "GetContext" :
        return make_get_context(Hashtbl.create(undefined, 0));
    case "Int" :
        return make_int(StringMap.empty);
    case "Record" :
        return make_record(StringMap.empty);
    case "SetContext" :
        return make_set_context(Hashtbl.create(undefined, 0));
    case "Slot" :
        return make_slot(/* [] */0);
    case "String" :
        return make_string(StringMap.empty);
    default:
      return Stdlib.failwith("No handler for " + (s + " provided."));
  }
}

var let$star = Result.bind;

export {
  let$star ,
  transform ,
  make_string ,
  make_int ,
  make_float ,
  make_boolean ,
  make_array ,
  make_record ,
  make_slot ,
  make_set_context ,
  make_get_context ,
  get_handler_for ,
}
/* Hashtbl Not a pure module */
