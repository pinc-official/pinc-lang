// Generated by Melange

import * as Int from "melange/lib/es6/int.js";
import * as Bool from "melange/lib/es6/bool.js";
import * as List from "melange/lib/es6/list.js";
import * as $$Array from "melange/lib/es6/array.js";
import * as Curry from "melange/lib/es6/curry.js";
import * as Float from "melange/lib/es6/float.js";
import * as Queue from "melange/lib/es6/queue.js";
import * as $$Buffer from "melange/lib/es6/buffer.js";
import * as Either from "melange/lib/es6/either.js";
import * as $$Option from "melange/lib/es6/option.js";
import * as Result from "melange/lib/es6/result.js";
import * as Stdlib from "melange/lib/es6/stdlib.js";
import * as $$String from "melange/lib/es6/string.js";
import * as Hashtbl from "melange/lib/es6/hashtbl.js";
import * as Caml_obj from "melange/lib/es6/caml_obj.js";
import * as Pinc_HTML from "./Pinc_HTML.js";
import * as StringMap from "./StringMap.js";
import * as Caml_int32 from "melange/lib/es6/caml_int32.js";
import * as Pinc_Typer from "./Pinc_Typer.js";
import * as Caml_option from "melange/lib/es6/caml_option.js";
import * as Pinc_Parser from "./Pinc_Parser.js";
import * as Caml_exceptions from "melange/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "melange/lib/es6/caml_js_exceptions.js";

var Loop_Break = /* @__PURE__ */Caml_exceptions.create("Pinc_Interpreter.Loop_Break");

var Loop_Continue = /* @__PURE__ */Caml_exceptions.create("Pinc_Interpreter.Loop_Continue");

function $$null(param) {
  return /* Null */0;
}

function of_string(s) {
  return {
          TAG: /* String */1,
          _0: s
        };
}

function of_bool(b) {
  return {
          TAG: /* Bool */4,
          _0: b
        };
}

function of_int(i) {
  return {
          TAG: /* Int */2,
          _0: i
        };
}

function of_float(f) {
  return {
          TAG: /* Float */3,
          _0: f
        };
}

function of_list(l) {
  return {
          TAG: /* Array */5,
          _0: $$Array.of_list(l)
        };
}

function of_string_map(m) {
  return {
          TAG: /* Record */6,
          _0: m
        };
}

function make_component(render, tag, attributes) {
  var result = Curry._1(render, attributes);
  return {
          TAG: /* ComponentTemplateNode */11,
          _0: render,
          _1: tag,
          _2: attributes,
          _3: result
        };
}

function to_string(_list) {
  while(true) {
    var list = _list;
    if (typeof list === "number") {
      return "";
    }
    switch (list.TAG | 0) {
      case /* Portal */0 :
          return $$String.concat("\n", List.rev_map(to_string, list._0));
      case /* String */1 :
          return list._0;
      case /* Int */2 :
          return String(list._0);
      case /* Float */3 :
          var f = list._0;
          if (Float.is_integer(f)) {
            return String(f | 0);
          } else {
            return Stdlib.string_of_float(f);
          }
      case /* Bool */4 :
          if (list._0) {
            return "true";
          } else {
            return "false";
          }
      case /* Array */5 :
          var buf = $$Buffer.create(200);
          $$Array.iteri((function(buf){
              return function (i, it) {
                if (i !== 0) {
                  $$Buffer.add_char(buf, /* '\n' */10);
                }
                $$Buffer.add_string(buf, to_string(it));
              }
              }(buf)), list._0);
          return $$Buffer.contents(buf);
      case /* Record */6 :
          var b = $$Buffer.create(1024);
          Curry._2(StringMap.iter, (function(b){
              return function (_key, value) {
                $$Buffer.add_string(b, to_string(value));
                $$Buffer.add_char(b, /* '\n' */10);
              }
              }(b)), list._0);
          return $$Buffer.contents(b);
      case /* Function */7 :
      case /* DefinitionInfo */8 :
          return "";
      case /* TagInfo */9 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Pinc_Interpreter.ml",
                  86,
                  19
                ],
                Error: new Error()
              };
      case /* HtmlTemplateNode */10 :
          var attributes = list._1;
          var tag = list._0;
          var buf$1 = $$Buffer.create(128);
          $$Buffer.add_char(buf$1, /* '<' */60);
          $$Buffer.add_string(buf$1, tag);
          if (!Curry._1(StringMap.is_empty, attributes)) {
            Curry._2(StringMap.iter, (function(buf$1){
                return function (key, value) {
                  if (typeof value === "number") {
                    return ;
                  }
                  if (value.TAG === /* TagInfo */9) {
                    throw {
                          RE_EXN_ID: "Assert_failure",
                          _1: [
                            "Pinc_Interpreter.ml",
                            72,
                            30
                          ],
                          Error: new Error()
                        };
                  }
                  $$Buffer.add_char(buf$1, /* ' ' */32);
                  $$Buffer.add_string(buf$1, key);
                  $$Buffer.add_char(buf$1, /* '=' */61);
                  $$Buffer.add_char(buf$1, /* '"' */34);
                  $$Buffer.add_string(buf$1, to_string(value));
                  $$Buffer.add_char(buf$1, /* '"' */34);
                }
                }(buf$1)), attributes);
          }
          if (list._3 && Pinc_HTML.is_void_el(tag)) {
            $$Buffer.add_string(buf$1, " />");
          } else {
            $$Buffer.add_char(buf$1, /* '>' */62);
            List.iter((function(buf$1){
                return function (child) {
                  $$Buffer.add_string(buf$1, to_string(child));
                }
                }(buf$1)), list._2);
            $$Buffer.add_char(buf$1, /* '<' */60);
            $$Buffer.add_char(buf$1, /* '/' */47);
            $$Buffer.add_string(buf$1, tag);
            $$Buffer.add_char(buf$1, /* '>' */62);
          }
          return $$Buffer.contents(buf$1);
      case /* ComponentTemplateNode */11 :
          _list = list._3;
          continue ;
      
    }
  };
}

function is_true(b) {
  if (typeof b === "number") {
    return false;
  }
  switch (b.TAG | 0) {
    case /* Portal */0 :
        return false;
    case /* String */1 :
        return $$String.trim(b._0).length !== 0;
    case /* Bool */4 :
        return b._0;
    case /* Array */5 :
        if (b._0.length) {
          return true;
        } else {
          return false;
        }
    case /* Record */6 :
        return !Curry._1(StringMap.is_empty, b._0);
    case /* DefinitionInfo */8 :
        return b._0[1] !== undefined;
    case /* TagInfo */9 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Pinc_Interpreter.ml",
                104,
                19
              ],
              Error: new Error()
            };
    default:
      return true;
  }
}

function equal(a, b) {
  if (typeof a === "number") {
    if (typeof b === "number") {
      return true;
    }
    if (b.TAG !== /* TagInfo */9) {
      return false;
    }
    
  } else {
    switch (a.TAG | 0) {
      case /* Portal */0 :
          break;
      case /* String */1 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* String */1 :
                return $$String.equal(a._0, b._0);
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* Int */2 :
          var a$1 = a._0;
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* Int */2 :
                return a$1 === b._0;
            case /* Float */3 :
                return a$1 === b._0;
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* Float */3 :
          var a$2 = a._0;
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* Int */2 :
                return a$2 === b._0;
            case /* Float */3 :
                return a$2 === b._0;
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* Bool */4 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* Bool */4 :
                return a._0 === b._0;
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* Array */5 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* Array */5 :
                return Caml_obj.caml_equal(a._0, b._0);
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* Record */6 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* Record */6 :
                return Curry._3(StringMap.equal, equal, a._0, b._0);
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* Function */7 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* Function */7 :
                return false;
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* DefinitionInfo */8 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* DefinitionInfo */8 :
                return $$String.equal(a._0[0], b._0[0]);
            case /* TagInfo */9 :
                break;
            default:
              return false;
          }
          break;
      case /* TagInfo */9 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Pinc_Interpreter.ml",
                  129,
                  22
                ],
                Error: new Error()
              };
      case /* HtmlTemplateNode */10 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* TagInfo */9 :
                break;
            case /* HtmlTemplateNode */10 :
                if (a._0 === b._0 && a._3 === b._3 && Curry._3(StringMap.equal, equal, a._1, b._1)) {
                  return Caml_obj.caml_equal(a._2, b._2);
                } else {
                  return false;
                }
            default:
              return false;
          }
          break;
      case /* ComponentTemplateNode */11 :
          if (typeof b === "number") {
            return false;
          }
          switch (b.TAG | 0) {
            case /* TagInfo */9 :
                break;
            case /* ComponentTemplateNode */11 :
                if (a._1 === b._1) {
                  return Curry._3(StringMap.equal, equal, a._2, b._2);
                } else {
                  return false;
                }
            default:
              return false;
          }
          break;
      
    }
  }
  if (typeof b === "number") {
    return false;
  }
  if (b.TAG !== /* TagInfo */9) {
    return false;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Pinc_Interpreter.ml",
          130,
          22
        ],
        Error: new Error()
      };
}

function compare(a, b) {
  if (typeof a === "number") {
    if (typeof b === "number") {
      return 0;
    }
    switch (b.TAG | 0) {
      case /* Portal */0 :
      case /* TagInfo */9 :
          break;
      default:
        return 0;
    }
  } else {
    switch (a.TAG | 0) {
      case /* Portal */0 :
          break;
      case /* String */1 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* String */1 :
                return $$String.compare(a._0, b._0);
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* Int */2 :
          var a$1 = a._0;
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Int */2 :
                return Int.compare(a$1, b._0);
            case /* Float */3 :
                return Float.compare(a$1, b._0);
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* Float */3 :
          var a$2 = a._0;
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Int */2 :
                return Float.compare(a$2, b._0);
            case /* Float */3 :
                return Float.compare(a$2, b._0);
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* Bool */4 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Bool */4 :
                return Bool.compare(a._0, b._0);
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* Array */5 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Array */5 :
                return Int.compare(a._0.length, b._0.length);
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* Record */6 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Record */6 :
                return Curry._3(StringMap.compare, compare, a._0, b._0);
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* Function */7 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Function */7 :
                return 0;
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* DefinitionInfo */8 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* DefinitionInfo */8 :
                return 0;
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            default:
              return 0;
          }
          break;
      case /* TagInfo */9 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Pinc_Interpreter.ml",
                  149,
                  22
                ],
                Error: new Error()
              };
      case /* HtmlTemplateNode */10 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            case /* HtmlTemplateNode */10 :
                return 0;
            default:
              return 0;
          }
          break;
      case /* ComponentTemplateNode */11 :
          if (typeof b === "number") {
            return 0;
          }
          switch (b.TAG | 0) {
            case /* Portal */0 :
            case /* TagInfo */9 :
                break;
            case /* ComponentTemplateNode */11 :
                return 0;
            default:
              return 0;
          }
          break;
      
    }
  }
  if (typeof b === "number") {
    return 0;
  }
  switch (b.TAG | 0) {
    case /* Portal */0 :
        return 0;
    case /* TagInfo */9 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Pinc_Interpreter.ml",
                150,
                22
              ],
              Error: new Error()
            };
    default:
      return 0;
  }
}

function merge(left, right) {
  if (typeof left !== "number") {
    switch (left.TAG | 0) {
      case /* Array */5 :
          if (typeof right === "number" || right.TAG !== /* Array */5) {
            return Stdlib.failwith("Trying to merge a non array value onto an array.");
          } else {
            return {
                    TAG: /* Array */5,
                    _0: $$Array.append(left._0, right._0)
                  };
          }
      case /* Record */6 :
          if (typeof right === "number") {
            return Stdlib.failwith("Trying to merge two non array values.");
          }
          switch (right.TAG | 0) {
            case /* Array */5 :
                break;
            case /* Record */6 :
                return {
                        TAG: /* Record */6,
                        _0: Curry._3(StringMap.union, (function (_key, _x, y) {
                                return y;
                              }), left._0, right._0)
                      };
            default:
              return Stdlib.failwith("Trying to merge two non array values.");
          }
          break;
      case /* HtmlTemplateNode */10 :
          if (typeof right === "number") {
            return Stdlib.failwith("Trying to merge a non record value onto tag attributes.");
          }
          if (right.TAG !== /* Record */6) {
            return Stdlib.failwith("Trying to merge a non record value onto tag attributes.");
          }
          var attributes = Curry._3(StringMap.union, (function (_key, _x, y) {
                  return y;
                }), left._1, right._0);
          return {
                  TAG: /* HtmlTemplateNode */10,
                  _0: left._0,
                  _1: attributes,
                  _2: left._2,
                  _3: left._3
                };
      case /* ComponentTemplateNode */11 :
          var fn = left._0;
          if (typeof right === "number") {
            return Stdlib.failwith("Trying to merge a non record value onto tag attributes.");
          }
          if (right.TAG !== /* Record */6) {
            return Stdlib.failwith("Trying to merge a non record value onto tag attributes.");
          }
          var attributes$1 = Curry._3(StringMap.union, (function (_key, _x, y) {
                  return y;
                }), left._2, right._0);
          var result = Curry._1(fn, attributes$1);
          return {
                  TAG: /* ComponentTemplateNode */11,
                  _0: fn,
                  _1: left._1,
                  _2: attributes$1,
                  _3: result
                };
      default:
        
    }
  }
  if (typeof right === "number" || right.TAG !== /* Array */5) {
    return Stdlib.failwith("Trying to merge two non array values.");
  } else {
    return Stdlib.failwith("Trying to merge an array value onto a non array.");
  }
}

function make(tag_listenersOpt, parent_component, contextOpt, portalsOpt, tag_cacheOpt, mode, declarations) {
  var tag_listeners = tag_listenersOpt !== undefined ? Caml_option.valFromOption(tag_listenersOpt) : Hashtbl.create(undefined, 10);
  var context = contextOpt !== undefined ? Caml_option.valFromOption(contextOpt) : Hashtbl.create(undefined, 10);
  var portals = portalsOpt !== undefined ? Caml_option.valFromOption(portalsOpt) : Hashtbl.create(undefined, 10);
  var tag_cache = tag_cacheOpt !== undefined ? Caml_option.valFromOption(tag_cacheOpt) : Hashtbl.create(undefined, 10);
  return {
          mode: mode,
          binding_identifier: undefined,
          declarations: declarations,
          output: /* Null */0,
          environment: {
            scope: /* [] */0,
            use_scope: /* [] */0
          },
          tag_listeners: tag_listeners,
          tag_cache: tag_cache,
          parent_tag: undefined,
          parent_component: parent_component,
          context: context,
          portals: portals
        };
}

function add_scope(t) {
  var init = t.environment;
  var environment = {
    scope: {
      hd: /* [] */0,
      tl: t.environment.scope
    },
    use_scope: init.use_scope
  };
  return {
          mode: t.mode,
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: t.output,
          environment: environment,
          tag_listeners: t.tag_listeners,
          tag_cache: t.tag_cache,
          parent_tag: t.parent_tag,
          parent_component: t.parent_component,
          context: t.context,
          portals: t.portals
        };
}

function add_value_to_scope(ident, value, is_optional, is_mutable, t) {
  var update_scope = function (t) {
    var match = t.environment.scope;
    if (match) {
      return {
              hd: {
                hd: [
                  ident,
                  {
                    is_mutable: is_mutable,
                    is_optional: is_optional,
                    value: value
                  }
                ],
                tl: match.hd
              },
              tl: match.tl
            };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Pinc_Interpreter.ml",
            210,
            14
          ],
          Error: new Error()
        };
  };
  var init = t.environment;
  var environment = {
    scope: update_scope(t),
    use_scope: init.use_scope
  };
  return {
          mode: t.mode,
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: t.output,
          environment: environment,
          tag_listeners: t.tag_listeners,
          tag_cache: t.tag_cache,
          parent_tag: t.parent_tag,
          parent_component: t.parent_component,
          context: t.context,
          portals: t.portals
        };
}

function add_value_to_use_scope(ident, value, t) {
  var use_scope_0 = [
    ident,
    value
  ];
  var use_scope_1 = t.environment.use_scope;
  var use_scope = {
    hd: use_scope_0,
    tl: use_scope_1
  };
  var init = t.environment;
  var environment = {
    scope: init.scope,
    use_scope: use_scope
  };
  return {
          mode: t.mode,
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: t.output,
          environment: environment,
          tag_listeners: t.tag_listeners,
          tag_cache: t.tag_cache,
          parent_tag: t.parent_tag,
          parent_component: t.parent_component,
          context: t.context,
          portals: t.portals
        };
}

function update_value_in_scope(ident, value, t) {
  var updated = {
    contents: false
  };
  var update_scope = function (state) {
    return List.map((function (scope) {
                  if (updated.contents) {
                    return scope;
                  } else {
                    return List.map((function (v) {
                                  var binding = v[1];
                                  var key = v[0];
                                  if (!updated.contents && key === ident && binding.is_mutable) {
                                    updated.contents = true;
                                    return [
                                            key,
                                            {
                                              is_mutable: binding.is_mutable,
                                              is_optional: binding.is_optional,
                                              value: value
                                            }
                                          ];
                                  }
                                  var match = binding.value;
                                  if (typeof match === "number") {
                                    return v;
                                  }
                                  if (match.TAG !== /* Function */7) {
                                    return v;
                                  }
                                  if (updated.contents) {
                                    return v;
                                  }
                                  var match$1 = match._0;
                                  var fn_state = match$1.state;
                                  fn_state.environment.scope = update_scope(fn_state);
                                  return [
                                          key,
                                          {
                                            is_mutable: binding.is_mutable,
                                            is_optional: binding.is_optional,
                                            value: {
                                              TAG: /* Function */7,
                                              _0: {
                                                parameters: match$1.parameters,
                                                state: fn_state,
                                                exec: match$1.exec
                                              }
                                            }
                                          }
                                        ];
                                }), scope);
                  }
                }), state.environment.scope);
  };
  t.environment.scope = update_scope(t);
}

function get_value_from_scope(ident, t) {
  return List.find_map((function (param) {
                return List.assoc_opt(ident, param);
              }), t.environment.scope);
}

function get_output(t) {
  return t.output;
}

function add_output(output, t) {
  return {
          mode: t.mode,
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: output,
          environment: t.environment,
          tag_listeners: t.tag_listeners,
          tag_cache: t.tag_cache,
          parent_tag: t.parent_tag,
          parent_component: t.parent_component,
          context: t.context,
          portals: t.portals
        };
}

function get_bindings(t) {
  return List.hd(t.environment.scope);
}

function get_parent_component(t) {
  return t.parent_component;
}

function eval_statement(state, expression) {
  if (typeof expression === "number") {
    if (expression === /* BreakStatement */0) {
      throw {
            RE_EXN_ID: Loop_Break,
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: Loop_Continue,
          Error: new Error()
        };
  } else {
    switch (expression.TAG | 0) {
      case /* UseStatement */0 :
          var ident = expression._0._0;
          var expression$1 = expression._1;
          var value = eval_expression(state, expression$1).output;
          return add_output(/* Null */0, add_value_to_use_scope(ident, value, state));
      case /* OptionalMutableLetStatement */1 :
          return eval_let(state, expression._0._0, true, true, expression._1);
      case /* OptionalLetStatement */2 :
          return eval_let(state, expression._0._0, false, true, expression._1);
      case /* MutableLetStatement */3 :
          return eval_let(state, expression._0._0, true, false, expression._1);
      case /* LetStatement */4 :
          return eval_let(state, expression._0._0, false, false, expression._1);
      case /* MutationStatement */5 :
          var ident$1 = expression._0._0;
          var expression$2 = expression._1;
          var current_binding = get_value_from_scope(ident$1, state);
          if (current_binding === undefined) {
            return Stdlib.failwith("Trying to update a variable, which does not exist in the current scope.");
          }
          if (!current_binding.is_mutable) {
            return Stdlib.failwith("Trying to update a non mutable variable.");
          }
          var is_optional = current_binding.is_optional;
          var output = eval_expression({
                mode: state.mode,
                binding_identifier: [
                  is_optional,
                  ident$1
                ],
                declarations: state.declarations,
                output: state.output,
                environment: state.environment,
                tag_listeners: state.tag_listeners,
                tag_cache: state.tag_cache,
                parent_tag: state.parent_tag,
                parent_component: state.parent_component,
                context: state.context,
                portals: state.portals
              }, expression$2);
          var value$1 = output.output;
          if (typeof value$1 === "number" && !is_optional) {
            Stdlib.failwith("identifier " + (ident$1 + " is not marked as nullable, but was tried to be updated with a null value."));
          } else {
            update_value_in_scope(ident$1, value$1, state);
          }
          return add_output(/* Null */0, state);
      case /* ExpressionStatement */6 :
          return eval_expression(state, expression._0);
      
    }
  }
}

function eval_expression(state, i) {
  switch (i.TAG | 0) {
    case /* String */0 :
        var template = i._0;
        return add_output({
                    TAG: /* String */1,
                    _0: $$String.concat("", List.map((function (s) {
                                if (s.TAG === /* StringInterpolation */0) {
                                  return to_string(eval_expression(state, s._0).output);
                                } else {
                                  return s._0;
                                }
                              }), template))
                  }, state);
    case /* Int */1 :
        return add_output({
                    TAG: /* Int */2,
                    _0: i._0
                  }, state);
    case /* Float */2 :
        var f = i._0;
        if (Float.is_integer(f)) {
          return add_output({
                      TAG: /* Int */2,
                      _0: f | 0
                    }, state);
        } else {
          return add_output({
                      TAG: /* Float */3,
                      _0: f
                    }, state);
        }
    case /* Bool */3 :
        return add_output({
                    TAG: /* Bool */4,
                    _0: i._0
                  }, state);
    case /* Array */4 :
        return add_output({
                    TAG: /* Array */5,
                    _0: $$Array.map((function (it) {
                            return eval_expression(state, it).output;
                          }), i._0)
                  }, state);
    case /* Record */5 :
        return add_output({
                    TAG: /* Record */6,
                    _0: Curry._2(StringMap.mapi, (function (ident, param) {
                            var optional = param[0];
                            var value = eval_expression({
                                  mode: state.mode,
                                  binding_identifier: [
                                    optional,
                                    ident
                                  ],
                                  declarations: state.declarations,
                                  output: state.output,
                                  environment: state.environment,
                                  tag_listeners: state.tag_listeners,
                                  tag_cache: state.tag_cache,
                                  parent_tag: state.parent_tag,
                                  parent_component: state.parent_component,
                                  context: state.context,
                                  portals: state.portals
                                }, param[1]).output;
                            if (typeof value === "number" && !optional) {
                              return Stdlib.failwith("identifier " + (ident + " is not marked as nullable, but was given a null value."));
                            } else {
                              return value;
                            }
                          }), i._0)
                  }, state);
    case /* Function */6 :
        var parameters = i._0;
        var body = i._1;
        var ident = state.binding_identifier;
        var self = {
          contents: /* Null */0
        };
        var exec = function ($$arguments, state, param) {
          var state$1 = ident !== undefined ? add_value_to_scope(ident[1], self.contents, false, false, state) : state;
          var state$2 = Curry._3(StringMap.fold, (function (ident, value) {
                  return function (param) {
                    return add_value_to_scope(ident, value, false, false, param);
                  };
                }), $$arguments, add_scope(state$1));
          return eval_expression(state$2, body).output;
        };
        var fn = {
          TAG: /* Function */7,
          _0: {
            parameters: parameters,
            state: state,
            exec: exec
          }
        };
        $$Option.iter((function (param) {
                var ident = param[1];
                var is_optional = false;
                var is_mutable = false;
                var update_scope = function (state) {
                  return List.map((function (param) {
                                return List.map((function (v) {
                                              var binding = v[1];
                                              var match = binding.value;
                                              if (typeof match === "number") {
                                                return v;
                                              }
                                              if (match.TAG !== /* Function */7) {
                                                return v;
                                              }
                                              var match$1 = match._0;
                                              var new_state = add_value_to_scope(ident, fn, is_optional, is_mutable, match$1.state);
                                              return [
                                                      v[0],
                                                      {
                                                        is_mutable: binding.is_mutable,
                                                        is_optional: binding.is_optional,
                                                        value: {
                                                          TAG: /* Function */7,
                                                          _0: {
                                                            parameters: match$1.parameters,
                                                            state: new_state,
                                                            exec: match$1.exec
                                                          }
                                                        }
                                                      }
                                                    ];
                                            }), param);
                              }), state.environment.scope);
                };
                state.environment.scope = update_scope(state);
              }), ident);
        self.contents = fn;
        return add_output(fn, state);
    case /* FunctionCall */7 :
        return eval_function_call(state, i._1, i._0);
    case /* UppercaseIdentifierExpression */8 :
        var id = i._0;
        var value = Curry._2(StringMap.find_opt, id, state.declarations);
        var typ;
        if (value !== undefined) {
          switch (value.TAG | 0) {
            case /* ComponentDeclaration */0 :
                typ = "Component";
                break;
            case /* LibraryDeclaration */1 :
                var declaration = eval_declaration(state, id);
                var top_level_bindings = List.hd(declaration.environment.scope);
                var used_values = declaration.environment.use_scope;
                typ = {
                  NAME: "Library",
                  VAL: [
                    top_level_bindings,
                    used_values
                  ]
                };
                break;
            case /* SiteDeclaration */2 :
                typ = "Site";
                break;
            case /* PageDeclaration */3 :
                typ = "Page";
                break;
            case /* StoreDeclaration */4 :
                typ = "Store";
                break;
            
          }
        } else {
          typ = undefined;
        }
        return add_output({
                    TAG: /* DefinitionInfo */8,
                    _0: [
                      id,
                      typ,
                      "NotNegated"
                    ]
                  }, state);
    case /* LowercaseIdentifierExpression */9 :
        var ident$1 = i._0;
        var param = get_value_from_scope(ident$1, state);
        if (param !== undefined) {
          return add_output(param.value, state);
        } else {
          return Stdlib.failwith("Unbound identifier `" + (ident$1 + "`"));
        }
    case /* TagExpression */10 :
        var tag = i._0;
        var transformer = tag.transformer;
        var attributes = tag.attributes;
        var tag$1 = tag.tag;
        var required = !$$Option.value($$Option.map((function (prim) {
                    return prim[0];
                  }), state.binding_identifier), false);
        var of_attribute = Curry._2(StringMap.find_opt, "of", attributes);
        var tag_attributes = Curry._2(StringMap.map, (function (it) {
                return eval_expression(state, it).output;
              }), Curry._2(StringMap.remove, "of", attributes));
        var match = Curry._2(StringMap.find_opt, "key", tag_attributes);
        var match$1 = state.binding_identifier;
        var match$2 = match !== undefined ? (
            typeof match === "number" || match.TAG !== /* String */1 ? Stdlib.failwith("Expected attribute `key` on tag to be of type string") : [
                match._0,
                state
              ]
          ) : (
            match$1 !== undefined ? [
                match$1[1],
                {
                  mode: state.mode,
                  binding_identifier: undefined,
                  declarations: state.declarations,
                  output: state.output,
                  environment: state.environment,
                  tag_listeners: state.tag_listeners,
                  tag_cache: state.tag_cache,
                  parent_tag: state.parent_tag,
                  parent_component: state.parent_component,
                  context: state.context,
                  portals: state.portals
                }
              ] : [
                "",
                state
              ]
          );
        var state$1 = match$2[1];
        var key = match$2[0];
        var path = Stdlib.$at($$Option.value(state$1.parent_tag, /* [] */0), {
              hd: key,
              tl: /* [] */0
            });
        var tag_attributes$1 = Curry._3(StringMap.add, "of", $$Option.value($$Option.map((function (it) {
                        return eval_expression({
                                    mode: state$1.mode,
                                    binding_identifier: state$1.binding_identifier,
                                    declarations: state$1.declarations,
                                    output: state$1.output,
                                    environment: state$1.environment,
                                    tag_listeners: state$1.tag_listeners,
                                    tag_cache: state$1.tag_cache,
                                    parent_tag: path,
                                    parent_component: state$1.parent_component,
                                    context: state$1.context,
                                    portals: state$1.portals
                                  }, it).output;
                      }), of_attribute), /* Null */0), Curry._2(StringMap.remove, "key", tag_attributes));
        var match$3 = state$1.mode;
        var value$1;
        if (tag$1 === "GetContext") {
          value$1 = $$Option.value(Hashtbl.find_opt(state$1.context, key), /* Null */0);
        } else if (tag$1 === "SetContext") {
          var value$2 = Curry._2(StringMap.find_opt, "value", tag_attributes$1);
          var value$3 = value$2 !== undefined ? (
              typeof value$2 === "number" || value$2.TAG !== /* Function */7 ? value$2 : Stdlib.failwith("a function can not be put into a context.")
            ) : Stdlib.failwith("attribute value is required when setting a context.");
          Hashtbl.add(state$1.context, key, value$3);
          value$1 = /* Null */0;
        } else if (tag$1 === "CreatePortal") {
          value$1 = {
            TAG: /* Portal */0,
            _0: Hashtbl.find_all(state$1.portals, key)
          };
        } else if (match$3) {
          value$1 = tag$1 === "Portal" ? /* Null */0 : $$Option.value($$Option.bind(Hashtbl.find_opt(state$1.tag_cache, key), Queue.take_opt), /* Null */0);
        } else {
          var exit = 0;
          if (typeof tag$1 === "string" && tag$1 === "Portal") {
            var value$4 = Curry._2(StringMap.find_opt, "push", tag_attributes$1);
            var push = value$4 !== undefined ? (
                typeof value$4 === "number" || value$4.TAG !== /* Function */7 ? value$4 : Stdlib.failwith("a function can not be put into a portal.")
              ) : Stdlib.failwith("attribute push is required when pushing a value into a portal.");
            Hashtbl.add(state$1.portals, key, push);
            value$1 = /* Null */0;
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var tag_info_transformer = function (param) {
              if (transformer === undefined) {
                return param;
              }
              var state$2 = add_value_to_scope(transformer[0]._0, param, false, false, add_scope(state$1));
              return eval_expression(state$2, transformer[1]).output;
            };
            var tag_info = {
              tag: tag$1,
              key: key,
              required: required,
              attributes: tag_attributes$1,
              transformer: tag_info_transformer
            };
            var match$4 = state$1.parent_tag;
            value$1 = match$4 !== undefined ? ({
                  TAG: /* TagInfo */9,
                  _0: tag_info
                }) : eval_internal_or_external_tag(state$1, undefined, tag_info);
          }
          
        }
        if (state$1.mode === /* Portal_Collection */0) {
          var q = Hashtbl.find_opt(state$1.tag_cache, key);
          if (q !== undefined) {
            Queue.add(value$1, Caml_option.valFromOption(q));
          } else {
            var q$1 = Queue.create(undefined);
            Queue.add(value$1, q$1);
            Hashtbl.add(state$1.tag_cache, key, q$1);
          }
        }
        return add_output(value$1, state$1);
    case /* ForInExpression */11 :
        var index_ident = i.index;
        var ident$2 = i.iterator._0;
        var reverse = i.reverse;
        var iterable = i.iterable;
        var body$1 = i.body;
        var iterable$1 = eval_expression(state, iterable).output;
        var index = {
          contents: -1
        };
        var loop = function (_acc, _param) {
          while(true) {
            var param = _param;
            var acc = _acc;
            if (!param) {
              return List.rev(acc);
            }
            var tl = param.tl;
            index.contents = index.contents + 1 | 0;
            var state$2 = add_value_to_scope(ident$2, param.hd, false, false, state);
            var state$3 = index_ident !== undefined ? add_value_to_scope(index_ident._0, {
                    TAG: /* Int */2,
                    _0: index.contents
                  }, false, false, state$2) : state$2;
            var v;
            try {
              v = eval_statement(state$3, body$1);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.RE_EXN_ID === Loop_Continue) {
                _param = tl;
                continue ;
              }
              if (exn.RE_EXN_ID === Loop_Break) {
                return List.rev(acc);
              }
              throw exn;
            }
            _param = tl;
            _acc = {
              hd: v.output,
              tl: acc
            };
            continue ;
          };
        };
        if (typeof iterable$1 === "number") {
          return add_output(/* Null */0, state);
        }
        switch (iterable$1.TAG | 0) {
          case /* Portal */0 :
              return Stdlib.failwith("Cannot iterate over portal value");
          case /* String */1 :
              var map = reverse ? (function (param) {
                    return List.rev_map((function (c) {
                                  return {
                                          TAG: /* String */1,
                                          _0: $$String.make(1, c)
                                        };
                                }), param);
                  }) : (function (param) {
                    return List.map((function (c) {
                                  return {
                                          TAG: /* String */1,
                                          _0: $$String.make(1, c)
                                        };
                                }), param);
                  });
              var l = loop(/* [] */0, Curry._1(map, List.of_seq($$String.to_seq(iterable$1._0))));
              var res = {
                TAG: /* Array */5,
                _0: $$Array.of_list(l)
              };
              return add_output(res, state);
          case /* Int */2 :
              return Stdlib.failwith("Cannot iterate over int value");
          case /* Float */3 :
              return Stdlib.failwith("Cannot iterate over float value");
          case /* Bool */4 :
              return Stdlib.failwith("Cannot iterate over boolean value");
          case /* Array */5 :
              var to_seq = function (array) {
                if (reverse) {
                  $$Array.stable_sort((function (param, param$1) {
                          return 1;
                        }), array);
                  return $$Array.to_seq(array);
                } else {
                  return $$Array.to_seq(array);
                }
              };
              var l$1 = loop(/* [] */0, List.of_seq(to_seq(iterable$1._0)));
              var res$1 = {
                TAG: /* Array */5,
                _0: $$Array.of_list(l$1)
              };
              return add_output(res$1, state);
          case /* Record */6 :
              return Stdlib.failwith("Cannot iterate over record value");
          case /* Function */7 :
              return Stdlib.failwith("Cannot iterate over function");
          case /* DefinitionInfo */8 :
              return Stdlib.failwith("Cannot iterate over definition info");
          case /* TagInfo */9 :
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "Pinc_Interpreter.ml",
                      869,
                      19
                    ],
                    Error: new Error()
                  };
          case /* HtmlTemplateNode */10 :
          case /* ComponentTemplateNode */11 :
              return Stdlib.failwith("Cannot iterate over template node");
          
        }
    case /* TemplateExpression */12 :
        var l$2 = List.map((function (it) {
                return eval_template(state, it).output;
              }), i._0);
        return add_output({
                    TAG: /* Array */5,
                    _0: $$Array.of_list(l$2)
                  }, state);
    case /* BlockExpression */13 :
        var statements = i._0;
        var state$2 = add_scope(state);
        return List.fold_left((function (state) {
                      return function (param) {
                        return eval_statement(state, param);
                      };
                    }), state$2, statements);
    case /* ConditionalExpression */14 :
        var condition = i.condition;
        var alternate = i.alternate;
        var consequent = i.consequent;
        var condition_matches = is_true(eval_expression(state, condition).output);
        if (condition_matches) {
          return eval_statement(state, consequent);
        } else if (alternate !== undefined) {
          return eval_statement(state, alternate);
        } else {
          return add_output(/* Null */0, state);
        }
    case /* UnaryExpression */15 :
        if (i._0) {
          var expression = i._1;
          var v = eval_expression(state, expression).output;
          if (typeof v === "number") {
            return add_output({
                        TAG: /* Bool */4,
                        _0: !is_true(v)
                      }, state);
          }
          if (v.TAG !== /* DefinitionInfo */8) {
            return add_output({
                        TAG: /* Bool */4,
                        _0: !is_true(v)
                      }, state);
          }
          var match$5 = v._0;
          var negated = match$5[2] === "Negated" ? "NotNegated" : "Negated";
          return add_output({
                      TAG: /* DefinitionInfo */8,
                      _0: [
                        match$5[0],
                        match$5[1],
                        negated
                      ]
                    }, state);
        } else {
          var expression$1 = i._1;
          var i$1 = eval_expression(state, expression$1).output;
          if (typeof i$1 === "number") {
            return Stdlib.failwith("Invalid usage of unary `-` operator. You are only able to negate integers or floats.");
          }
          switch (i$1.TAG | 0) {
            case /* Int */2 :
                return add_output({
                            TAG: /* Int */2,
                            _0: -i$1._0 | 0
                          }, state);
            case /* Float */3 :
                return add_output({
                            TAG: /* Float */3,
                            _0: -i$1._0
                          }, state);
            default:
              return Stdlib.failwith("Invalid usage of unary `-` operator. You are only able to negate integers or floats.");
          }
        }
    case /* BinaryExpression */16 :
        var left = i._0;
        switch (i._1) {
          case /* EQUAL */0 :
              var right = i._2;
              var a = eval_expression(state, left).output;
              var b = eval_expression(state, right).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: equal(a, b)
                        }, state);
          case /* NOT_EQUAL */1 :
              var right$1 = i._2;
              var a$1 = eval_expression(state, left).output;
              var b$1 = eval_expression(state, right$1).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: !equal(a$1, b$1)
                        }, state);
          case /* GREATER */2 :
              var right$2 = i._2;
              var a$2 = eval_expression(state, left).output;
              var b$2 = eval_expression(state, right$2).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: compare(a$2, b$2) > 0
                        }, state);
          case /* GREATER_EQUAL */3 :
              var right$3 = i._2;
              var a$3 = eval_expression(state, left).output;
              var b$3 = eval_expression(state, right$3).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: compare(a$3, b$3) >= 0
                        }, state);
          case /* LESS */4 :
              var right$4 = i._2;
              var a$4 = eval_expression(state, left).output;
              var b$4 = eval_expression(state, right$4).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: compare(a$4, b$4) < 0
                        }, state);
          case /* LESS_EQUAL */5 :
              var right$5 = i._2;
              var a$5 = eval_expression(state, left).output;
              var b$5 = eval_expression(state, right$5).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: compare(a$5, b$5) <= 0
                        }, state);
          case /* PLUS */6 :
              var right$6 = i._2;
              var a$6 = eval_expression(state, left).output;
              var b$6 = eval_expression(state, right$6).output;
              if (typeof a$6 === "number") {
                return Stdlib.failwith("Trying to add non numeric literals.");
              }
              switch (a$6.TAG | 0) {
                case /* Int */2 :
                    var a$7 = a$6._0;
                    if (typeof b$6 === "number") {
                      return Stdlib.failwith("Trying to add non numeric literals.");
                    }
                    switch (b$6.TAG | 0) {
                      case /* Int */2 :
                          return add_output({
                                      TAG: /* Int */2,
                                      _0: a$7 + b$6._0 | 0
                                    }, state);
                      case /* Float */3 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$7 + b$6._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Trying to add non numeric literals.");
                    }
                case /* Float */3 :
                    var a$8 = a$6._0;
                    if (typeof b$6 === "number") {
                      return Stdlib.failwith("Trying to add non numeric literals.");
                    }
                    switch (b$6.TAG | 0) {
                      case /* Int */2 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$8 + b$6._0
                                    }, state);
                      case /* Float */3 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$8 + b$6._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Trying to add non numeric literals.");
                    }
                default:
                  return Stdlib.failwith("Trying to add non numeric literals.");
              }
          case /* MINUS */7 :
              var right$7 = i._2;
              var a$9 = eval_expression(state, left).output;
              var b$7 = eval_expression(state, right$7).output;
              if (typeof a$9 === "number") {
                return Stdlib.failwith("Trying to subtract non numeric literals.");
              }
              switch (a$9.TAG | 0) {
                case /* Int */2 :
                    var a$10 = a$9._0;
                    if (typeof b$7 === "number") {
                      return Stdlib.failwith("Trying to subtract non numeric literals.");
                    }
                    switch (b$7.TAG | 0) {
                      case /* Int */2 :
                          return add_output({
                                      TAG: /* Int */2,
                                      _0: a$10 - b$7._0 | 0
                                    }, state);
                      case /* Float */3 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$10 - b$7._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Trying to subtract non numeric literals.");
                    }
                case /* Float */3 :
                    var a$11 = a$9._0;
                    if (typeof b$7 === "number") {
                      return Stdlib.failwith("Trying to subtract non numeric literals.");
                    }
                    switch (b$7.TAG | 0) {
                      case /* Int */2 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$11 - b$7._0
                                    }, state);
                      case /* Float */3 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$11 - b$7._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Trying to subtract non numeric literals.");
                    }
                default:
                  return Stdlib.failwith("Trying to subtract non numeric literals.");
              }
          case /* TIMES */8 :
              var right$8 = i._2;
              var a$12 = eval_expression(state, left).output;
              var b$8 = eval_expression(state, right$8).output;
              if (typeof a$12 === "number") {
                return Stdlib.failwith("Trying to multiply non numeric literals.");
              }
              switch (a$12.TAG | 0) {
                case /* Int */2 :
                    var a$13 = a$12._0;
                    if (typeof b$8 === "number") {
                      return Stdlib.failwith("Trying to multiply non numeric literals.");
                    }
                    switch (b$8.TAG | 0) {
                      case /* Int */2 :
                          return add_output({
                                      TAG: /* Int */2,
                                      _0: Math.imul(a$13, b$8._0)
                                    }, state);
                      case /* Float */3 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$13 * b$8._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Trying to multiply non numeric literals.");
                    }
                case /* Float */3 :
                    var a$14 = a$12._0;
                    if (typeof b$8 === "number") {
                      return Stdlib.failwith("Trying to multiply non numeric literals.");
                    }
                    switch (b$8.TAG | 0) {
                      case /* Int */2 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$14 * b$8._0
                                    }, state);
                      case /* Float */3 :
                          return add_output({
                                      TAG: /* Float */3,
                                      _0: a$14 * b$8._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Trying to multiply non numeric literals.");
                    }
                default:
                  return Stdlib.failwith("Trying to multiply non numeric literals.");
              }
          case /* DIV */9 :
              var right$9 = i._2;
              var a$15 = eval_expression(state, left).output;
              var b$9 = eval_expression(state, right$9).output;
              var r;
              if (typeof a$15 === "number") {
                r = Stdlib.failwith("Trying to divide non numeric literals.");
              } else {
                switch (a$15.TAG | 0) {
                  case /* Int */2 :
                      var a$16 = a$15._0;
                      if (typeof b$9 === "number") {
                        r = Stdlib.failwith("Trying to divide non numeric literals.");
                      } else {
                        switch (b$9.TAG | 0) {
                          case /* Int */2 :
                              var b$10 = b$9._0;
                              r = b$10 !== 0 ? a$16 / b$10 : Stdlib.failwith("Trying to divide by 0");
                              break;
                          case /* Float */3 :
                              var b$11 = b$9._0;
                              r = b$11 !== 0 ? a$16 / b$11 : Stdlib.failwith("Trying to divide by 0");
                              break;
                          default:
                            r = Stdlib.failwith("Trying to divide non numeric literals.");
                        }
                      }
                      break;
                  case /* Float */3 :
                      var a$17 = a$15._0;
                      if (typeof b$9 === "number") {
                        r = Stdlib.failwith("Trying to divide non numeric literals.");
                      } else {
                        switch (b$9.TAG | 0) {
                          case /* Int */2 :
                              var b$12 = b$9._0;
                              r = b$12 !== 0 ? a$17 / b$12 : Stdlib.failwith("Trying to divide by 0");
                              break;
                          case /* Float */3 :
                              var b$13 = b$9._0;
                              r = b$13 !== 0 ? a$17 / b$13 : Stdlib.failwith("Trying to divide by 0");
                              break;
                          default:
                            r = Stdlib.failwith("Trying to divide non numeric literals.");
                        }
                      }
                      break;
                  default:
                    r = Stdlib.failwith("Trying to divide non numeric literals.");
                }
              }
              if (Float.is_integer(r)) {
                return add_output({
                            TAG: /* Int */2,
                            _0: r | 0
                          }, state);
              } else {
                return add_output({
                            TAG: /* Float */3,
                            _0: r
                          }, state);
              }
          case /* POW */10 :
              var right$10 = i._2;
              var a$18 = eval_expression(state, left).output;
              var b$14 = eval_expression(state, right$10).output;
              var r$1;
              if (typeof a$18 === "number") {
                r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
              } else {
                switch (a$18.TAG | 0) {
                  case /* Int */2 :
                      var a$19 = a$18._0;
                      if (typeof b$14 === "number") {
                        r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                      } else {
                        switch (b$14.TAG | 0) {
                          case /* Int */2 :
                              r$1 = Math.pow(a$19, b$14._0);
                              break;
                          case /* Float */3 :
                              r$1 = Math.pow(a$19, b$14._0);
                              break;
                          default:
                            r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                        }
                      }
                      break;
                  case /* Float */3 :
                      var a$20 = a$18._0;
                      if (typeof b$14 === "number") {
                        r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                      } else {
                        switch (b$14.TAG | 0) {
                          case /* Int */2 :
                              r$1 = Math.pow(a$20, b$14._0);
                              break;
                          case /* Float */3 :
                              r$1 = Math.pow(a$20, b$14._0);
                              break;
                          default:
                            r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                        }
                      }
                      break;
                  default:
                    r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                }
              }
              if (Float.is_integer(r$1)) {
                return add_output({
                            TAG: /* Int */2,
                            _0: r$1 | 0
                          }, state);
              } else {
                return add_output({
                            TAG: /* Float */3,
                            _0: r$1
                          }, state);
              }
          case /* MODULO */11 :
              var right$11 = i._2;
              var a$21 = eval_expression(state, left).output;
              var b$15 = eval_expression(state, right$11).output;
              var r$2;
              if (typeof a$21 === "number") {
                r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
              } else {
                switch (a$21.TAG | 0) {
                  case /* Int */2 :
                      var a$22 = a$21._0;
                      if (typeof b$15 === "number") {
                        r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                      } else {
                        switch (b$15.TAG | 0) {
                          case /* Int */2 :
                              var b$16 = b$15._0;
                              r$2 = b$16 !== 0 ? Caml_int32.mod_(a$22, b$16) : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                              break;
                          case /* Float */3 :
                              var b$17 = b$15._0;
                              r$2 = b$17 !== 0 ? Caml_int32.mod_(a$22, b$17 | 0) : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                              break;
                          default:
                            r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                        }
                      }
                      break;
                  case /* Float */3 :
                      var a$23 = a$21._0;
                      if (typeof b$15 === "number") {
                        r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                      } else {
                        switch (b$15.TAG | 0) {
                          case /* Int */2 :
                              var b$18 = b$15._0;
                              r$2 = b$18 !== 0 ? Caml_int32.mod_(a$23 | 0, b$18) : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                              break;
                          case /* Float */3 :
                              var b$19 = b$15._0;
                              r$2 = b$19 !== 0 ? a$23 % b$19 | 0 : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                              break;
                          default:
                            r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                        }
                      }
                      break;
                  default:
                    r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                }
              }
              return add_output({
                          TAG: /* Int */2,
                          _0: r$2
                        }, state);
          case /* CONCAT */12 :
              var right$12 = i._2;
              var a$24 = eval_expression(state, left).output;
              var b$20 = eval_expression(state, right$12).output;
              if (typeof a$24 === "number" || !(a$24.TAG === /* String */1 && !(typeof b$20 === "number" || b$20.TAG !== /* String */1))) {
                return Stdlib.failwith("Trying to concat non string literals.");
              } else {
                return add_output({
                            TAG: /* String */1,
                            _0: a$24._0 + b$20._0
                          }, state);
              }
          case /* AND */13 :
              var right$13 = i._2;
              var a$25 = eval_expression(state, left).output;
              var b$21 = eval_expression(state, right$13).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: is_true(a$25) && is_true(b$21)
                        }, state);
          case /* OR */14 :
              var right$14 = i._2;
              var a$26 = eval_expression(state, left).output;
              var b$22 = eval_expression(state, right$14).output;
              return add_output({
                          TAG: /* Bool */4,
                          _0: is_true(a$26) || is_true(b$22)
                        }, state);
          case /* DOT_ACCESS */15 :
              var right$15 = i._2;
              var left$1 = eval_expression(state, left).output;
              if (typeof left$1 === "number") {
                return add_output(/* Null */0, state);
              }
              switch (left$1.TAG | 0) {
                case /* Record */6 :
                    if (right$15.TAG !== /* LowercaseIdentifierExpression */9) {
                      return Stdlib.failwith("Expected right hand side of record access to be a lowercase identifier.");
                    }
                    var output = $$Option.value(Curry._2(StringMap.find_opt, right$15._0, left$1._0), /* Null */0);
                    return add_output(output, state);
                case /* DefinitionInfo */8 :
                    var match$6 = left$1._0;
                    var maybe_library = match$6[1];
                    var name = match$6[0];
                    switch (right$15.TAG | 0) {
                      case /* UppercaseIdentifierExpression */8 :
                          var match$7 = List.assoc_opt(name, state.environment.use_scope);
                          var use_scope;
                          if (match$7 !== undefined) {
                            if (typeof match$7 === "number") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (match$7.TAG !== /* DefinitionInfo */8) {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            var match$8 = match$7._0[1];
                            if (match$8 === undefined) {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (typeof match$8 === "string") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (match$8.NAME !== "Library") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            use_scope = match$8.VAL[1];
                          } else {
                            if (maybe_library === undefined) {
                              return add_output(/* Null */0, state);
                            }
                            if (typeof maybe_library === "string") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (maybe_library.NAME !== "Library") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            use_scope = maybe_library.VAL[1];
                          }
                          return add_output($$Option.value(List.assoc_opt(right$15._0, use_scope), /* Null */0), state);
                      case /* LowercaseIdentifierExpression */9 :
                          var match$9 = List.assoc_opt(name, state.environment.use_scope);
                          var top_level_bindings$1;
                          if (match$9 !== undefined) {
                            if (typeof match$9 === "number") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (match$9.TAG !== /* DefinitionInfo */8) {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            var match$10 = match$9._0[1];
                            if (match$10 === undefined) {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (typeof match$10 === "string") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (match$10.NAME !== "Library") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            top_level_bindings$1 = match$10.VAL[0];
                          } else {
                            if (maybe_library === undefined) {
                              return add_output(/* Null */0, state);
                            }
                            if (typeof maybe_library === "string") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            if (maybe_library.NAME !== "Library") {
                              return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                            }
                            top_level_bindings$1 = maybe_library.VAL[0];
                          }
                          return add_output($$Option.value($$Option.map((function (b) {
                                                return b.value;
                                              }), List.assoc_opt(right$15._0, top_level_bindings$1)), /* Null */0), state);
                      default:
                        if (maybe_library !== undefined) {
                          return Stdlib.failwith("I am really not sure what you are trying to do here...");
                        } else {
                          return Stdlib.failwith("Trying to access a property on a non existant library `" + (name + "` ."));
                        }
                    }
                    break;
                case /* HtmlTemplateNode */10 :
                    if (right$15.TAG !== /* LowercaseIdentifierExpression */9) {
                      return Stdlib.failwith("I am really not sure what you are trying to do here...");
                    }
                    var b$23 = right$15._0;
                    switch (b$23) {
                      case "attributes" :
                          return add_output({
                                      TAG: /* Record */6,
                                      _0: left$1._1
                                    }, state);
                      case "tag" :
                          return add_output({
                                      TAG: /* String */1,
                                      _0: left$1._0
                                    }, state);
                      default:
                        return Stdlib.failwith("Unknown property " + (b$23 + " on template node. Known properties are: `tag` and `attributes`."));
                    }
                case /* ComponentTemplateNode */11 :
                    if (right$15.TAG !== /* LowercaseIdentifierExpression */9) {
                      return Stdlib.failwith("I am really not sure what you are trying to do here...");
                    }
                    var b$24 = right$15._0;
                    switch (b$24) {
                      case "attributes" :
                          return add_output({
                                      TAG: /* Record */6,
                                      _0: left$1._2
                                    }, state);
                      case "tag" :
                          return add_output({
                                      TAG: /* String */1,
                                      _0: left$1._1
                                    }, state);
                      default:
                        return Stdlib.failwith("Unknown property " + (b$24 + " on component. Known properties are: `tag` and`attributes`."));
                    }
                default:
                  if (right$15.TAG === /* LowercaseIdentifierExpression */9) {
                    return Stdlib.failwith("Trying to access a property on a non record, library or template value.");
                  } else {
                    return Stdlib.failwith("I am really not sure what you are trying to do here...");
                  }
              }
          case /* BRACKET_ACCESS */16 :
              var right$16 = i._2;
              var left$2 = eval_expression(state, left).output;
              var right$17 = eval_expression(state, right$16).output;
              if (typeof left$2 === "number") {
                return add_output(/* Null */0, state);
              }
              switch (left$2.TAG | 0) {
                case /* Array */5 :
                    if (typeof right$17 === "number") {
                      return Stdlib.failwith("Cannot access array with a non integer value.");
                    }
                    if (right$17.TAG !== /* Int */2) {
                      return Stdlib.failwith("Cannot access array with a non integer value.");
                    }
                    var output$1;
                    try {
                      output$1 = left$2._0[right$17._0];
                    }
                    catch (exn){
                      output$1 = /* Null */0;
                    }
                    return add_output(output$1, state);
                case /* Record */6 :
                    if (typeof right$17 === "number") {
                      return Stdlib.failwith("Cannot access record with a non string value.");
                    }
                    if (right$17.TAG !== /* String */1) {
                      return Stdlib.failwith("Cannot access record with a non string value.");
                    }
                    var output$2 = $$Option.value(Curry._2(StringMap.find_opt, right$17._0, left$2._0), /* Null */0);
                    return add_output(output$2, state);
                default:
                  return Stdlib.failwith("Trying to access a property on a non record or array value.");
              }
          case /* FUNCTION_CALL */17 :
              return eval_function_call(state, {
                          hd: i._2,
                          tl: /* [] */0
                        }, left);
          case /* PIPE */18 :
              var right$18 = i._2;
              var right$19;
              right$19 = right$18.TAG === /* FunctionCall */7 ? ({
                    TAG: /* FunctionCall */7,
                    _0: right$18._0,
                    _1: {
                      hd: left,
                      tl: right$18._1
                    }
                  }) : ({
                    TAG: /* FunctionCall */7,
                    _0: right$18,
                    _1: {
                      hd: left,
                      tl: /* [] */0
                    }
                  });
              return eval_expression(state, right$19);
          case /* ARRAY_ADD */19 :
              var right$20 = i._2;
              var left$3 = eval_expression(state, left).output;
              var right$21 = eval_expression(state, right$20).output;
              if (typeof left$3 === "number" || left$3.TAG !== /* Array */5) {
                return Stdlib.failwith("Trying to add an element on a non array value.");
              } else {
                return add_output({
                            TAG: /* Array */5,
                            _0: $$Array.append(left$3._0, [right$21])
                          }, state);
              }
          case /* MERGE */20 :
              var right$22 = i._2;
              var left$4 = eval_expression(state, left).output;
              var right$23 = eval_expression(state, right$22).output;
              return add_output(merge(left$4, right$23), state);
          case /* RANGE */21 :
              return eval_range(state, false, left, i._2);
          case /* INCLUSIVE_RANGE */22 :
              return eval_range(state, true, left, i._2);
          
        }
    
  }
}

function eval_function_call(state, $$arguments, left) {
  var maybe_fn = eval_expression(state, left).output;
  if (typeof maybe_fn === "number") {
    return Stdlib.failwith("Trying to call a non function value");
  }
  if (maybe_fn.TAG !== /* Function */7) {
    return Stdlib.failwith("Trying to call a non function value");
  }
  var match = maybe_fn._0;
  var parameters = match.parameters;
  if (List.compare_lengths(parameters, $$arguments) === 0) {
    var $$arguments$1 = List.fold_left((function (acc, param) {
            var value = eval_expression(state, param[1]).output;
            return Curry._3(StringMap.add, param[0], value, acc);
          }), StringMap.empty, List.combine(parameters, $$arguments));
    return add_output(Curry._3(match.exec, $$arguments$1, match.state, undefined), state);
  }
  if (List.compare_lengths(parameters, $$arguments) <= 0) {
    return Stdlib.failwith("This function only accepts " + (String(List.length(parameters)) + (" arguments, but was provided " + (String(List.length($$arguments)) + " here."))));
  }
  var arguments_len = List.length($$arguments);
  var missing = $$String.concat(", ", List.map((function (item) {
              return "`" + (item + "`");
            }), List.filteri((function (index, param) {
                  return index > (arguments_len - 1 | 0);
                }), parameters)));
  return Stdlib.failwith("This function was provided too few arguments. The following parameters are missing: " + missing);
}

function eval_let(state, ident, is_mutable, is_optional, expression) {
  var state$1 = eval_expression({
        mode: state.mode,
        binding_identifier: [
          is_optional,
          ident
        ],
        declarations: state.declarations,
        output: state.output,
        environment: state.environment,
        tag_listeners: state.tag_listeners,
        tag_cache: state.tag_cache,
        parent_tag: state.parent_tag,
        parent_component: state.parent_component,
        context: state.context,
        portals: state.portals
      }, expression);
  var value = state$1.output;
  if (typeof value === "number" && !is_optional) {
    return Stdlib.failwith("identifier " + (ident + " is not marked as nullable, but was given a null value."));
  }
  return add_output(/* Null */0, add_value_to_scope(ident, value, is_optional, is_mutable, state$1));
}

function eval_range(state, inclusive, from, upto) {
  var from$1 = eval_expression(state, from).output;
  var upto$1 = eval_expression(state, upto).output;
  var get_range = function (from, upto) {
    if (typeof from !== "number" && from.TAG === /* Int */2) {
      if (typeof upto === "number" || upto.TAG !== /* Int */2) {
        return Stdlib.failwith("Can't construct range in for loop. The end of your range is not of type int.");
      } else {
        return [
                from._0,
                upto._0
              ];
      }
    }
    if (typeof upto === "number" || upto.TAG !== /* Int */2) {
      return Stdlib.failwith("Can't construct range in for loop. The start and end of your range are not of type int.");
    } else {
      return Stdlib.failwith("Can't construct range in for loop. The start of your range is not of type int.");
    }
  };
  var match = get_range(from$1, upto$1);
  var upto$2 = match[1];
  var from$2 = match[0];
  var iter;
  if (from$2 > upto$2) {
    iter = [];
  } else {
    var stop = inclusive ? upto$2 + 1 | 0 : upto$2;
    iter = $$Array.init(stop - from$2 | 0, (function (i) {
            return {
                    TAG: /* Int */2,
                    _0: i + from$2 | 0
                  };
          }));
  }
  return add_output({
              TAG: /* Array */5,
              _0: iter
            }, state);
}

function eval_slot(attributes, slotted_elements, key) {
  var find_slot_key = function (attributes) {
    var s = $$Option.value(Curry._2(StringMap.find_opt, "slot", attributes), {
          TAG: /* String */1,
          _0: ""
        });
    if (typeof s === "number" || s.TAG !== /* String */1) {
      return Stdlib.failwith("Expected slot attribute to be of type string");
    } else {
      return s._0;
    }
  };
  var keep_slotted = function (acc, l) {
    if (typeof l === "number") {
      return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
    }
    switch (l.TAG | 0) {
      case /* String */1 :
          if ($$String.trim(l._0) === "") {
            return acc;
          } else {
            return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
          }
      case /* Array */5 :
          return $$Array.fold_left(keep_slotted, acc, l._0);
      case /* HtmlTemplateNode */10 :
          var attributes = l._1;
          if (find_slot_key(attributes) === key) {
            return {
                    hd: {
                      TAG: /* HtmlTemplateNode */10,
                      _0: l._0,
                      _1: attributes,
                      _2: l._2,
                      _3: l._3
                    },
                    tl: acc
                  };
          } else {
            return acc;
          }
      case /* ComponentTemplateNode */11 :
          var attributes$1 = l._2;
          if (find_slot_key(attributes$1) === key) {
            return {
                    hd: {
                      TAG: /* ComponentTemplateNode */11,
                      _0: l._0,
                      _1: l._1,
                      _2: attributes$1,
                      _3: l._3
                    },
                    tl: acc
                  };
          } else {
            return acc;
          }
      default:
        return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
    }
  };
  var slotted_elements$1 = List.rev(List.fold_left(keep_slotted, /* [] */0, slotted_elements));
  var min = $$Option.value(Pinc_Typer.Expect.maybe((function (param) {
              return Pinc_Typer.Expect.attribute("min", Pinc_Typer.Expect.$$int, param);
            }), attributes), 0);
  var max = (function (param) {
        return $$Option.value(param, Int.max_int);
      })(Pinc_Typer.Expect.maybe((function (param) {
              return Pinc_Typer.Expect.attribute("max", Pinc_Typer.Expect.$$int, param);
            }), attributes));
  var partial_arg = "Component";
  var partial_arg$1 = function (param) {
    return Pinc_Typer.Expect.definition_info(partial_arg, param);
  };
  var partial_arg$2 = function (param) {
    return Pinc_Typer.Expect.required(partial_arg$1, param);
  };
  var partial_arg$3 = function (param) {
    return Pinc_Typer.Expect.array(partial_arg$2, param);
  };
  var constraints = Pinc_Typer.Expect.maybe((function (param) {
          return Pinc_Typer.Expect.attribute("constraints", partial_arg$3, param);
        }), attributes);
  var check_instance_restriction = function (tag) {
    if (constraints === undefined) {
      return Result.ok(undefined);
    }
    var is_in_list = {
      contents: false
    };
    var match = List.partition_map((function (param) {
            var name = param[1];
            if (name === tag) {
              is_in_list.contents = true;
            }
            if (param[2]) {
              return Either.right(name);
            } else {
              return Either.left(name);
            }
          }), constraints);
    var allowed = match[0];
    var is_in_list$1 = is_in_list.contents;
    var is_allowed = allowed ? (
        match[1] ? List.mem(tag, allowed) : is_in_list$1
      ) : !is_in_list$1;
    if (is_allowed) {
      return Result.ok(undefined);
    } else {
      return Result.error("Child with tag `" + (tag + ("` may not be used inside this #Slot . The following restrictions are set: [ " + ($$String.concat(",", List.map((function (param) {
                                  var name = param[1];
                                  if (param[2]) {
                                    return "!" + name;
                                  } else {
                                    return name;
                                  }
                                }), $$Option.value(constraints, /* [] */0))) + " ]"))));
    }
  };
  var num_slotted_elements = List.length(slotted_elements$1);
  if (num_slotted_elements < min) {
    return Stdlib.failwith("#Slot did not reach the minimum amount of nodes (specified as " + (String(min) + ")."));
  }
  if (num_slotted_elements > max) {
    return Stdlib.failwith("#Slot includes more than the maximum amount of nodes (specified as " + (String(max) + ")."));
  }
  var match = List.partition_map((function (v) {
          var tag;
          if (typeof v === "number") {
            return Either.right("Tried to assign a non node value to a #Slot. Only nodes template nodes are allowed inside slots. If you want to put another value (like a string) into a slot, you have to wrap it in some node.");
          }
          switch (v.TAG | 0) {
            case /* HtmlTemplateNode */10 :
                tag = v._0;
                break;
            case /* ComponentTemplateNode */11 :
                tag = v._1;
                break;
            default:
              return Either.right("Tried to assign a non node value to a #Slot. Only nodes template nodes are allowed inside slots. If you want to put another value (like a string) into a slot, you have to wrap it in some node.");
          }
          var e = check_instance_restriction(tag);
          if (e.TAG === /* Ok */0) {
            return Either.left(v);
          } else {
            return Either.right(e._0);
          }
        }), slotted_elements$1);
  var failed = match[1];
  if (failed) {
    return Stdlib.failwith(failed.hd);
  } else {
    return {
            TAG: /* Array */5,
            _0: $$Array.of_list(match[0])
          };
  }
}

function eval_internal_tag(state, key, attributes, value_bag, tag_name) {
  if (tag_name === "Boolean") {
    return $$Option.value($$Option.map(of_bool, Pinc_Typer.Expect.attribute(key, Pinc_Typer.Expect.bool, value_bag)), /* Null */0);
  }
  if (tag_name === "Int") {
    return $$Option.value($$Option.map(of_int, Pinc_Typer.Expect.attribute(key, Pinc_Typer.Expect.$$int, value_bag)), /* Null */0);
  }
  if (tag_name === "Float") {
    return $$Option.value($$Option.map(of_float, Pinc_Typer.Expect.attribute(key, Pinc_Typer.Expect.$$float, value_bag)), /* Null */0);
  }
  if (tag_name === "Record") {
    var of$p = Pinc_Typer.Expect.required((function (param) {
            return Pinc_Typer.Expect.attribute("of", Pinc_Typer.Expect.record, param);
          }), attributes);
    return $$Option.value($$Option.map((function (record) {
                      return {
                              TAG: /* Record */6,
                              _0: Curry._3(StringMap.merge, (function (_key, x, y) {
                                      if (x !== undefined) {
                                        if (y !== undefined && typeof y !== "number" && y.TAG === /* TagInfo */9) {
                                          return eval_internal_or_external_tag(state, Caml_option.some(record), y._0);
                                        }
                                        
                                      } else if (y !== undefined && typeof y !== "number" && y.TAG === /* TagInfo */9) {
                                        return /* Null */0;
                                      }
                                      if (y !== undefined) {
                                        return y;
                                      }
                                      
                                    }), record, of$p)
                            };
                    }), Pinc_Typer.Expect.attribute(key, Pinc_Typer.Expect.record, value_bag)), /* Null */0);
  }
  if (tag_name !== "Array") {
    return $$Option.value($$Option.map(of_string, Pinc_Typer.Expect.attribute(key, Pinc_Typer.Expect.string, value_bag)), /* Null */0);
  }
  var of$p$1 = Pinc_Typer.Expect.required((function (param) {
          return Pinc_Typer.Expect.attribute("of", Pinc_Typer.Expect.tag_info, param);
        }), attributes);
  return $$Option.value($$Option.map((function (array) {
                    var l = List.mapi((function (index, item) {
                            var key = String(index);
                            return eval_internal_or_external_tag(state, Caml_option.some(Curry._2(StringMap.singleton, key, item)), {
                                        tag: of$p$1.tag,
                                        key: key,
                                        required: of$p$1.required,
                                        attributes: of$p$1.attributes,
                                        transformer: of$p$1.transformer
                                      });
                          }), array);
                    return {
                            TAG: /* Array */5,
                            _0: $$Array.of_list(l)
                          };
                  }), Pinc_Typer.Expect.attribute(key, (function (param) {
                        return Pinc_Typer.Expect.array(Pinc_Typer.Expect.any_value, param);
                      }), value_bag)), /* Null */0);
}

function eval_internal_or_external_tag(state, value, tag_info) {
  var transformer = tag_info.transformer;
  var attributes = tag_info.attributes;
  var key = tag_info.key;
  var tag = tag_info.tag;
  var match = state.parent_component;
  var value_bag;
  var slotted_elements;
  if (value !== undefined) {
    var value_bag$1 = Caml_option.valFromOption(value);
    if (match === undefined) {
      return call_tag_listener(state, Caml_option.some(value_bag$1), tag_info);
    }
    value_bag = value_bag$1;
    slotted_elements = match[2];
  } else {
    if (match === undefined) {
      return call_tag_listener(state, undefined, tag_info);
    }
    value_bag = match[1];
    slotted_elements = match[2];
  }
  if (typeof tag === "string") {
    if (tag === "Slot") {
      return Curry._1(transformer, eval_slot(attributes, slotted_elements, key));
    } else {
      return Curry._1(transformer, eval_internal_tag(state, key, attributes, value_bag, tag));
    }
  } else {
    return call_tag_listener(state, Caml_option.some(value_bag), tag_info);
  }
}

function call_tag_listener(state, value_bag, t) {
  var attributes = t.attributes;
  var required = t.required;
  var key = t.key;
  var listener = Hashtbl.find_opt(state.tag_listeners, t.tag);
  var v;
  if (listener !== undefined) {
    var variant = listener.NAME;
    if (variant === "Custom") {
      v = Curry._4(listener.VAL, required, attributes, value_bag, key);
    } else if (variant === "Record") {
      var children = Curry._2(StringMap.filter_map, (function (_key) {
              return function (param) {
                return Pinc_Typer.Expect.maybe(Pinc_Typer.Expect.tag_info, param);
              };
            }), Pinc_Typer.Expect.required((function (param) {
                  return Pinc_Typer.Expect.attribute("of", Pinc_Typer.Expect.record, param);
                }), attributes));
      v = Curry._4(listener.VAL, required, attributes, children, key);
    } else if (variant === "Array") {
      var child = Pinc_Typer.Expect.required((function (param) {
              return Pinc_Typer.Expect.attribute("of", Pinc_Typer.Expect.tag_info, param);
            }), attributes);
      v = Curry._4(listener.VAL, required, attributes, child, key);
    } else {
      v = Curry._3(listener.VAL, required, attributes, key);
    }
  } else {
    v = Result.ok(/* Null */0);
  }
  if (v.TAG === /* Ok */0) {
    return Curry._1(t.transformer, v._0);
  } else {
    return Stdlib.failwith(v._0);
  }
}

function eval_template(state, template) {
  switch (template.TAG | 0) {
    case /* HtmlTemplateNode */0 :
        var attributes = Curry._2(StringMap.map, get_output, Curry._2(StringMap.map, (function (param) {
                    return eval_expression(state, param);
                  }), template.attributes));
        var children = List.map(get_output, List.map((function (param) {
                    return eval_template(state, param);
                  }), template.children));
        return add_output({
                    TAG: /* HtmlTemplateNode */10,
                    _0: template.tag,
                    _1: attributes,
                    _2: children,
                    _3: template.self_closing
                  }, state);
    case /* ComponentTemplateNode */1 :
        var tag = template.identifier._0;
        var attributes$1 = Curry._2(StringMap.map, get_output, Curry._2(StringMap.map, (function (param) {
                    return eval_expression(state, param);
                  }), template.attributes));
        var children$1 = List.map(get_output, List.map((function (param) {
                    return eval_template(state, param);
                  }), template.children));
        var render_fn = function (attributes) {
          var state$1 = make(Caml_option.some(state.tag_listeners), [
                tag,
                attributes,
                children$1
              ], Caml_option.some(state.context), Caml_option.some(state.portals), Caml_option.some(state.tag_cache), state.mode, state.declarations);
          return eval_declaration(state$1, tag).output;
        };
        var result = render_fn(attributes$1);
        return add_output({
                    TAG: /* ComponentTemplateNode */11,
                    _0: render_fn,
                    _1: tag,
                    _2: attributes$1,
                    _3: result
                  }, state);
    case /* ExpressionTemplateNode */2 :
        return eval_expression(state, template._0);
    case /* TextTemplateNode */3 :
        return add_output({
                    TAG: /* String */1,
                    _0: template._0
                  }, state);
    
  }
}

function eval_declaration(state, declaration) {
  var param = Curry._2(StringMap.find_opt, declaration, state.declarations);
  if (param !== undefined) {
    return eval_expression(state, param._1);
  } else {
    return Stdlib.failwith("Declaration with name `" + (declaration + "` was not found."));
  }
}

function eval_meta(tag_listeners, declarations) {
  var state = make(tag_listeners, undefined, undefined, undefined, undefined, /* Render */1, declarations);
  var $$eval = function (attrs) {
    return Curry._2(StringMap.map, (function (e) {
                  return eval_expression(state, e).output;
                }), (function (param) {
                    return $$Option.value(param, StringMap.empty);
                  })(attrs));
  };
  return Curry._2(StringMap.map, (function (param) {
                switch (param.TAG | 0) {
                  case /* ComponentDeclaration */0 :
                      return {
                              NAME: "Component",
                              VAL: $$eval(param._0)
                            };
                  case /* LibraryDeclaration */1 :
                      return {
                              NAME: "Library",
                              VAL: $$eval(param._0)
                            };
                  case /* SiteDeclaration */2 :
                      return {
                              NAME: "Site",
                              VAL: $$eval(param._0)
                            };
                  case /* PageDeclaration */3 :
                      return {
                              NAME: "Page",
                              VAL: $$eval(param._0)
                            };
                  case /* StoreDeclaration */4 :
                      return {
                              NAME: "Store",
                              VAL: $$eval(param._0)
                            };
                  
                }
              }), declarations);
}

function $$eval(tag_listeners, root, declarations) {
  var state = make(tag_listeners, undefined, undefined, undefined, undefined, /* Portal_Collection */0, declarations);
  var state$1 = eval_declaration(state, root);
  if (Hashtbl.length(state$1.portals) > 0) {
    return eval_declaration({
                mode: /* Render */1,
                binding_identifier: state$1.binding_identifier,
                declarations: state$1.declarations,
                output: state$1.output,
                environment: state$1.environment,
                tag_listeners: state$1.tag_listeners,
                tag_cache: state$1.tag_cache,
                parent_tag: state$1.parent_tag,
                parent_component: state$1.parent_component,
                context: state$1.context,
                portals: state$1.portals
              }, root);
  } else {
    return state$1;
  }
}

function from_source(filenameOpt, source, root) {
  var filename = filenameOpt !== undefined ? filenameOpt : "";
  var declarations = Pinc_Parser.parse(filename, source);
  return $$eval(undefined, root, declarations);
}

var Value = {
  to_string: to_string,
  $$null: $$null,
  of_string: of_string,
  of_bool: of_bool,
  of_int: of_int,
  of_float: of_float,
  of_list: of_list,
  of_string_map: of_string_map,
  make_component: make_component
};

var State = {
  get_output: get_output,
  get_bindings: get_bindings,
  get_parent_component: get_parent_component
};

export {
  Value ,
  State ,
  eval_meta ,
  $$eval ,
  from_source ,
}
/* Float Not a pure module */
