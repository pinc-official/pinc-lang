// Generated by Melange

import * as Int from "bs-platform/lib/es6/int.js";
import * as Bool from "bs-platform/lib/es6/bool.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Float from "bs-platform/lib/es6/float.js";
import * as $$Buffer from "bs-platform/lib/es6/buffer.js";
import * as Either from "bs-platform/lib/es6/either.js";
import * as $$Option from "bs-platform/lib/es6/option.js";
import * as Stdlib from "bs-platform/lib/es6/stdlib.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Hashtbl from "bs-platform/lib/es6/hashtbl.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Pinc_Ast from "./Pinc_Ast.js";
import * as Pinc_HTML from "./Pinc_HTML.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Caml_module from "bs-platform/lib/es6/caml_module.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Pinc_Parser from "./Pinc_Parser.js";
import * as Caml_exceptions from "bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

var Loop_Break = /* @__PURE__ */Caml_exceptions.create("Pinc_Interpreter.Loop_Break");

var Loop_Continue = /* @__PURE__ */Caml_exceptions.create("Pinc_Interpreter.Loop_Continue");

function validate(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return Stdlib.failwith("tried to assign definition info to a string tag.");
  }
  if (variant !== "TagInfo") {
    if (variant === "Function") {
      return Stdlib.failwith("tried to assign function to a string tag.");
    } else if (variant === "Int") {
      return Stdlib.failwith("tried to assign integer value to a string tag.");
    } else if (variant === "Float") {
      return Stdlib.failwith("tried to assign float value to a string tag.");
    } else if (variant === "Bool") {
      return Stdlib.failwith("tried to assign boolean value to a string tag.");
    } else if (variant === "Record") {
      return Stdlib.failwith("tried to assign record value to a string tag.");
    } else if (variant === "TemplateNode") {
      return Stdlib.failwith("tried to assign template node to a string tag.");
    } else if (variant === "Array") {
      return Stdlib.failwith("tried to assign array value to a string tag.");
    } else {
      return {
              NAME: "String",
              VAL: param.VAL
            };
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$1(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return Stdlib.failwith("tried to assign definition info to a int tag.");
  }
  if (variant !== "TagInfo") {
    if (variant === "Function") {
      return Stdlib.failwith("tried to assign function to a int tag.");
    } else if (variant === "Int") {
      return {
              NAME: "Int",
              VAL: param.VAL
            };
    } else if (variant === "Float") {
      return Stdlib.failwith("tried to assign float value to a int tag.");
    } else if (variant === "Bool") {
      return Stdlib.failwith("tried to assign boolean value to a int tag.");
    } else if (variant === "Record") {
      return Stdlib.failwith("tried to assign record value to a int tag.");
    } else if (variant === "TemplateNode") {
      return Stdlib.failwith("tried to assign template node to a int tag.");
    } else if (variant === "Array") {
      return Stdlib.failwith("tried to assign array value to a int tag.");
    } else {
      return Stdlib.failwith("tried to assign string value to a int tag.");
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$2(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return Stdlib.failwith("tried to assign definition info to a float tag.");
  }
  if (variant !== "TagInfo") {
    if (variant === "Function") {
      return Stdlib.failwith("tried to assign function to a float tag.");
    } else if (variant === "Int") {
      return Stdlib.failwith("tried to assign int value to a float tag.");
    } else if (variant === "Float") {
      return {
              NAME: "Float",
              VAL: param.VAL
            };
    } else if (variant === "Bool") {
      return Stdlib.failwith("tried to assign boolean value to a float tag.");
    } else if (variant === "Record") {
      return Stdlib.failwith("tried to assign record value to a float tag.");
    } else if (variant === "TemplateNode") {
      return Stdlib.failwith("tried to assign template node to a float tag.");
    } else if (variant === "Array") {
      return Stdlib.failwith("tried to assign array value to a float tag.");
    } else {
      return Stdlib.failwith("tried to assign string value to a float tag.");
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$3(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return Stdlib.failwith("tried to assign definition info to a boolean tag.");
  }
  if (variant !== "TagInfo") {
    if (variant === "Function") {
      return Stdlib.failwith("tried to assign function to a boolean tag.");
    } else if (variant === "Int") {
      return Stdlib.failwith("tried to assign int value to a boolean tag.");
    } else if (variant === "Float") {
      return Stdlib.failwith("tried to assign float value to a boolean tag.");
    } else if (variant === "Bool") {
      return {
              NAME: "Bool",
              VAL: param.VAL
            };
    } else if (variant === "Record") {
      return Stdlib.failwith("tried to assign record value to a boolean tag.");
    } else if (variant === "TemplateNode") {
      return Stdlib.failwith("tried to assign template node to a boolean tag.");
    } else if (variant === "Array") {
      return Stdlib.failwith("tried to assign array value to a boolean tag.");
    } else {
      return Stdlib.failwith("tried to assign string value to a boolean tag.");
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$4(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return Stdlib.failwith("tried to assign definition info to a array tag.");
  }
  if (variant !== "TagInfo") {
    if (variant === "Function") {
      return Stdlib.failwith("tried to assign function to a array tag.");
    } else if (variant === "Int") {
      return Stdlib.failwith("tried to assign int value to a array tag.");
    } else if (variant === "Float") {
      return Stdlib.failwith("tried to assign float value to a array tag.");
    } else if (variant === "Bool") {
      return Stdlib.failwith("tried to assign boolean value to a array tag.");
    } else if (variant === "Record") {
      return Stdlib.failwith("tried to assign record value to a array tag.");
    } else if (variant === "TemplateNode") {
      return Stdlib.failwith("tried to assign template node to a array tag.");
    } else if (variant === "Array") {
      return {
              NAME: "Array",
              VAL: param.VAL
            };
    } else {
      return Stdlib.failwith("tried to assign string value to a array tag.");
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$5(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return Stdlib.failwith("tried to assign definition info to a record tag.");
  }
  if (variant !== "TagInfo") {
    if (variant === "Function") {
      return Stdlib.failwith("tried to assign function to a record tag.");
    } else if (variant === "Int") {
      return Stdlib.failwith("tried to assign int value to a record tag.");
    } else if (variant === "Float") {
      return Stdlib.failwith("tried to assign float value to a record tag.");
    } else if (variant === "Bool") {
      return Stdlib.failwith("tried to assign boolean value to a record tag.");
    } else if (variant === "Record") {
      return {
              NAME: "Record",
              VAL: param.VAL
            };
    } else if (variant === "TemplateNode") {
      return Stdlib.failwith("tried to assign template node to a record tag.");
    } else if (variant === "Array") {
      return Stdlib.failwith("tried to assign array value to a record tag.");
    } else {
      return Stdlib.failwith("tried to assign string value to a record tag.");
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$6(param) {
  if (typeof param === "string") {
    return "Null";
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function validate$7(v) {
  if (typeof v === "string") {
    return v;
  }
  if (v.NAME !== "TagInfo") {
    return v;
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

var Value = Caml_module.init_mod([
      "Pinc_Interpreter.ml",
      517,
      6
    ], {
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "null"
        ],
        [
          /* Function */0,
          "of_string"
        ],
        [
          /* Function */0,
          "of_bool"
        ],
        [
          /* Function */0,
          "of_int"
        ],
        [
          /* Function */0,
          "of_float"
        ],
        [
          /* Function */0,
          "of_list"
        ],
        [
          /* Function */0,
          "of_string_map"
        ],
        [
          /* Function */0,
          "make_component"
        ],
        [
          /* Function */0,
          "to_string"
        ],
        [
          /* Function */0,
          "is_true"
        ],
        [
          /* Function */0,
          "equal"
        ],
        [
          /* Function */0,
          "compare"
        ]
      ]
    });

var State = Caml_module.init_mod([
      "Pinc_Interpreter.ml",
      731,
      6
    ], {
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "make"
        ],
        [
          /* Function */0,
          "add_scope"
        ],
        [
          /* Function */0,
          "add_value_to_scope"
        ],
        [
          /* Function */0,
          "add_value_to_function_scopes"
        ],
        [
          /* Function */0,
          "update_value_in_scope"
        ],
        [
          /* Function */0,
          "get_value_from_scope"
        ],
        [
          /* Function */0,
          "get_output"
        ],
        [
          /* Function */0,
          "add_output"
        ],
        [
          /* Function */0,
          "get_bindings"
        ],
        [
          /* Function */0,
          "call_tag_listener"
        ]
      ]
    });

function $$null(param) {
  return "Null";
}

function of_string(s) {
  return {
          NAME: "String",
          VAL: s
        };
}

function of_bool(b) {
  return {
          NAME: "Bool",
          VAL: b
        };
}

function of_int(i) {
  return {
          NAME: "Int",
          VAL: i
        };
}

function of_float(f) {
  return {
          NAME: "Float",
          VAL: f
        };
}

function of_list(l) {
  return {
          NAME: "Array",
          VAL: $$Array.of_list(l)
        };
}

function of_string_map(m) {
  return {
          NAME: "Record",
          VAL: m
        };
}

function make_component(render, tag, attributes, children) {
  return {
          NAME: "TemplateNode",
          VAL: [
            {
              NAME: "Component",
              VAL: render
            },
            tag,
            attributes,
            children,
            false
          ]
        };
}

function to_string(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "string") {
      return "";
    }
    var variant = param.NAME;
    if (variant === "DefinitionInfo") {
      return "";
    }
    if (variant === "TagInfo") {
      var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
      throw {
            RE_EXN_ID: Internal_Error,
            Error: new Error()
          };
    }
    if (variant === "Function") {
      return "";
    }
    if (variant === "Int") {
      return String(param.VAL);
    }
    if (variant === "Float") {
      var f = param.VAL;
      if (Float.is_integer(f)) {
        return String(f | 0);
      } else {
        return Stdlib.string_of_float(f);
      }
    }
    if (variant === "Bool") {
      if (param.VAL) {
        return "true";
      } else {
        return "false";
      }
    }
    if (variant === "Record") {
      var b = $$Buffer.create(1024);
      Curry._2(Pinc_Ast.StringMap.iter, (function(b){
          return function (_key, value) {
            $$Buffer.add_string(b, to_string(value));
            return $$Buffer.add_char(b, /* '\n' */10);
          }
          }(b)), param.VAL);
      return $$Buffer.contents(b);
    }
    if (variant === "TemplateNode") {
      var match = param.VAL;
      var match$1 = match[0];
      if (typeof match$1 === "string") {
        var attributes = match[2];
        var tag = match[1];
        var buf = $$Buffer.create(128);
        $$Buffer.add_char(buf, /* '<' */60);
        $$Buffer.add_string(buf, tag);
        if (!Curry._1(Pinc_Ast.StringMap.is_empty, attributes)) {
          Curry._2(Pinc_Ast.StringMap.iter, (function(buf){
              return function (key, value) {
                if (typeof value === "string") {
                  return ;
                }
                if (value.NAME === "TagInfo") {
                  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
                  throw {
                        RE_EXN_ID: Internal_Error,
                        Error: new Error()
                      };
                }
                $$Buffer.add_char(buf, /* ' ' */32);
                $$Buffer.add_string(buf, key);
                $$Buffer.add_char(buf, /* '=' */61);
                $$Buffer.add_char(buf, /* '"' */34);
                $$Buffer.add_string(buf, to_string(value));
                return $$Buffer.add_char(buf, /* '"' */34);
              }
              }(buf)), attributes);
        }
        if (match[4] && Pinc_HTML.is_void_el(tag)) {
          $$Buffer.add_string(buf, " />");
        } else {
          $$Buffer.add_char(buf, /* '>' */62);
          List.iter((function(buf){
              return function (child) {
                return $$Buffer.add_string(buf, to_string(child));
              }
              }(buf)), match[3]);
          $$Buffer.add_char(buf, /* '<' */60);
          $$Buffer.add_char(buf, /* '/' */47);
          $$Buffer.add_string(buf, tag);
          $$Buffer.add_char(buf, /* '>' */62);
        }
        return $$Buffer.contents(buf);
      }
      _param = Curry._1(match$1.VAL, undefined);
      continue ;
    }
    if (variant !== "Array") {
      return param.VAL;
    }
    var buf$1 = $$Buffer.create(200);
    $$Array.iteri((function(buf$1){
        return function (i, it) {
          if (i !== 0) {
            $$Buffer.add_char(buf$1, /* '\n' */10);
          }
          return $$Buffer.add_string(buf$1, to_string(it));
        }
        }(buf$1)), param.VAL);
    return $$Buffer.contents(buf$1);
  };
}

function is_true(param) {
  if (typeof param === "string") {
    return false;
  }
  var variant = param.NAME;
  if (variant === "DefinitionInfo") {
    return param.VAL[1] === "Exists";
  }
  if (variant !== "TagInfo") {
    if (variant === "TemplateNode" || variant === "Float" || variant === "Int" || variant === "Function") {
      return true;
    } else if (variant === "Bool") {
      return param.VAL;
    } else if (variant === "Record") {
      return !Curry._1(Pinc_Ast.StringMap.is_empty, param.VAL);
    } else if (variant === "Array") {
      if (param.VAL.length) {
        return true;
      } else {
        return false;
      }
    } else {
      return $$String.trim(param.VAL).length !== 0;
    }
  }
  var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error,
        Error: new Error()
      };
}

function equal(a, b) {
  if (typeof a === "string") {
    if (a === "Null" && b === "Null") {
      return true;
    }
    
  } else {
    var variant = a.NAME;
    if (variant === "String") {
      if (typeof b !== "string" && b.NAME === "String") {
        return $$String.equal(a.VAL, b.VAL);
      }
      
    } else if (variant === "DefinitionInfo") {
      if (typeof b !== "string" && b.NAME === "DefinitionInfo") {
        return $$String.equal(a.VAL[0], b.VAL[0]);
      }
      
    } else {
      if (variant === "TagInfo") {
        var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
        throw {
              RE_EXN_ID: Internal_Error,
              Error: new Error()
            };
      }
      if (variant === "Function") {
        if (typeof b !== "string" && b.NAME === "Function") {
          return false;
        }
        
      } else if (variant === "Int") {
        if (typeof b !== "string") {
          var variant$1 = b.NAME;
          var a$1 = a.VAL;
          if (variant$1 === "Int") {
            return a$1 === b.VAL;
          }
          if (variant$1 === "Float") {
            return a$1 === b.VAL;
          }
          
        }
        
      } else if (variant === "Float") {
        if (typeof b !== "string") {
          var variant$2 = b.NAME;
          var a$2 = a.VAL;
          if (variant$2 === "Int") {
            return a$2 === b.VAL;
          }
          if (variant$2 === "Float") {
            return a$2 === b.VAL;
          }
          
        }
        
      } else if (variant === "Bool") {
        if (typeof b !== "string" && b.NAME === "Bool") {
          return Caml_obj.caml_equal(a.VAL, b.VAL);
        }
        
      } else if (variant === "Record") {
        if (typeof b !== "string" && b.NAME === "Record") {
          return Curry._3(Pinc_Ast.StringMap.equal, equal, a.VAL, b.VAL);
        }
        
      } else if (variant === "TemplateNode") {
        if (typeof b !== "string" && b.NAME === "TemplateNode") {
          var match = b.VAL;
          var match$1 = a.VAL;
          if (Caml_obj.caml_equal(match$1[0], match[0]) && Caml_obj.caml_equal(match$1[1], match[1]) && Caml_obj.caml_equal(match$1[4], match[4]) && Curry._3(Pinc_Ast.StringMap.equal, equal, match$1[2], match[2])) {
            return Caml_obj.caml_equal(match$1[3], match[3]);
          } else {
            return false;
          }
        }
        
      } else if (variant === "Array" && typeof b !== "string" && b.NAME === "Array") {
        return Caml_obj.caml_equal(a.VAL, b.VAL);
      }
      
    }
  }
  if (typeof b === "string") {
    return false;
  }
  if (b.NAME !== "TagInfo") {
    return false;
  }
  var Internal_Error$1 = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error$1,
        Error: new Error()
      };
}

function compare(a, b) {
  if (typeof a === "string") {
    if (a === "Null" && b === "Null") {
      return 0;
    }
    
  } else {
    var variant = a.NAME;
    if (variant === "String") {
      if (typeof b !== "string" && b.NAME === "String") {
        return $$String.compare(a.VAL, b.VAL);
      }
      
    } else if (variant === "DefinitionInfo") {
      if (typeof b !== "string" && b.NAME === "DefinitionInfo") {
        return 0;
      }
      
    } else {
      if (variant === "TagInfo") {
        var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
        throw {
              RE_EXN_ID: Internal_Error,
              Error: new Error()
            };
      }
      if (variant === "Function") {
        if (typeof b !== "string" && b.NAME === "Function") {
          return 0;
        }
        
      } else if (variant === "Int") {
        if (typeof b !== "string") {
          var variant$1 = b.NAME;
          var a$1 = a.VAL;
          if (variant$1 === "Int") {
            return Int.compare(a$1, b.VAL);
          }
          if (variant$1 === "Float") {
            return Float.compare(a$1, b.VAL);
          }
          
        }
        
      } else if (variant === "Float") {
        if (typeof b !== "string") {
          var variant$2 = b.NAME;
          var a$2 = a.VAL;
          if (variant$2 === "Int") {
            return Float.compare(a$2, b.VAL);
          }
          if (variant$2 === "Float") {
            return Float.compare(a$2, b.VAL);
          }
          
        }
        
      } else if (variant === "Bool") {
        if (typeof b !== "string" && b.NAME === "Bool") {
          return Bool.compare(a.VAL, b.VAL);
        }
        
      } else if (variant === "Record") {
        if (typeof b !== "string" && b.NAME === "Record") {
          return Curry._3(Pinc_Ast.StringMap.compare, compare, a.VAL, b.VAL);
        }
        
      } else if (variant === "TemplateNode") {
        if (typeof b !== "string" && b.NAME === "TemplateNode") {
          return 0;
        }
        
      } else if (variant === "Array" && typeof b !== "string" && b.NAME === "Array") {
        return Int.compare(a.VAL.length, b.VAL.length);
      }
      
    }
  }
  if (typeof b === "string") {
    var Internal_Error$1 = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
    throw {
          RE_EXN_ID: Internal_Error$1,
          Error: new Error()
        };
  }
  if (b.NAME === "TagInfo") {
    var Internal_Error$2 = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
    throw {
          RE_EXN_ID: Internal_Error$2,
          Error: new Error()
        };
  }
  var Internal_Error$3 = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
  throw {
        RE_EXN_ID: Internal_Error$3,
        Error: new Error()
      };
}

Caml_module.update_mod({
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "null"
        ],
        [
          /* Function */0,
          "of_string"
        ],
        [
          /* Function */0,
          "of_bool"
        ],
        [
          /* Function */0,
          "of_int"
        ],
        [
          /* Function */0,
          "of_float"
        ],
        [
          /* Function */0,
          "of_list"
        ],
        [
          /* Function */0,
          "of_string_map"
        ],
        [
          /* Function */0,
          "make_component"
        ],
        [
          /* Function */0,
          "to_string"
        ],
        [
          /* Function */0,
          "is_true"
        ],
        [
          /* Function */0,
          "equal"
        ],
        [
          /* Function */0,
          "compare"
        ]
      ]
    }, Value, {
      $$null: $$null,
      of_string: of_string,
      of_bool: of_bool,
      of_int: of_int,
      of_float: of_float,
      of_list: of_list,
      of_string_map: of_string_map,
      make_component: make_component,
      to_string: to_string,
      is_true: is_true,
      equal: equal,
      compare: compare
    });

function make(tag_listenersOpt, declarations) {
  var tag_listeners = tag_listenersOpt !== undefined ? Caml_option.valFromOption(tag_listenersOpt) : Pinc_Ast.StringMap.empty;
  return {
          binding_identifier: undefined,
          declarations: declarations,
          output: "Null",
          environment: {
            scope: /* [] */0
          },
          tag_listeners: tag_listeners,
          tag_info: false
        };
}

function add_scope(t) {
  var environment = {
    scope: {
      hd: /* [] */0,
      tl: t.environment.scope
    }
  };
  return {
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: t.output,
          environment: environment,
          tag_listeners: t.tag_listeners,
          tag_info: t.tag_info
        };
}

function add_value_to_scope(ident, value, is_optional, is_mutable, t) {
  var update_scope = function (t) {
    var match = t.environment.scope;
    if (match) {
      return {
              hd: {
                hd: [
                  ident,
                  {
                    is_mutable: is_mutable,
                    is_optional: is_optional,
                    value: value
                  }
                ],
                tl: match.hd
              },
              tl: match.tl
            };
    }
    var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
    throw {
          RE_EXN_ID: Internal_Error,
          Error: new Error()
        };
  };
  var environment = {
    scope: update_scope(t)
  };
  return {
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: t.output,
          environment: environment,
          tag_listeners: t.tag_listeners,
          tag_info: t.tag_info
        };
}

function update_value_in_scope(ident, value, t) {
  var updated = {
    contents: false
  };
  var update_scope = function (state) {
    return List.map((function (scope) {
                  if (updated.contents) {
                    return scope;
                  } else {
                    return List.map((function (v) {
                                  var binding = v[1];
                                  var key = v[0];
                                  if (!updated.contents && key === ident && binding.is_mutable) {
                                    updated.contents = true;
                                    return [
                                            key,
                                            {
                                              is_mutable: binding.is_mutable,
                                              is_optional: binding.is_optional,
                                              value: value
                                            }
                                          ];
                                  }
                                  var match = binding.value;
                                  if (typeof match === "string") {
                                    return v;
                                  }
                                  if (match.NAME !== "Function") {
                                    return v;
                                  }
                                  if (updated.contents) {
                                    return v;
                                  }
                                  var match$1 = match.VAL;
                                  var fn_state = match$1.state;
                                  fn_state.environment.scope = update_scope(fn_state);
                                  return [
                                          key,
                                          {
                                            is_mutable: binding.is_mutable,
                                            is_optional: binding.is_optional,
                                            value: {
                                              NAME: "Function",
                                              VAL: {
                                                parameters: match$1.parameters,
                                                state: fn_state,
                                                exec: match$1.exec
                                              }
                                            }
                                          }
                                        ];
                                }), scope);
                  }
                }), state.environment.scope);
  };
  t.environment.scope = update_scope(t);
}

function add_value_to_function_scopes(ident, value, is_optional, is_mutable, t) {
  var update_scope = function (state) {
    return List.map((function (param) {
                  return List.map((function (v) {
                                var binding = v[1];
                                var match = binding.value;
                                if (typeof match === "string") {
                                  return v;
                                }
                                if (match.NAME !== "Function") {
                                  return v;
                                }
                                var match$1 = match.VAL;
                                var new_state = add_value_to_scope(ident, value, is_optional, is_mutable, match$1.state);
                                return [
                                        v[0],
                                        {
                                          is_mutable: binding.is_mutable,
                                          is_optional: binding.is_optional,
                                          value: {
                                            NAME: "Function",
                                            VAL: {
                                              parameters: match$1.parameters,
                                              state: new_state,
                                              exec: match$1.exec
                                            }
                                          }
                                        }
                                      ];
                              }), param);
                }), state.environment.scope);
  };
  t.environment.scope = update_scope(t);
}

function get_value_from_scope(ident, t) {
  return List.find_map((function (param) {
                return List.assoc_opt(ident, param);
              }), t.environment.scope);
}

function get_output(t) {
  return t.output;
}

function add_output(output, t) {
  return {
          binding_identifier: t.binding_identifier,
          declarations: t.declarations,
          output: output,
          environment: t.environment,
          tag_listeners: t.tag_listeners,
          tag_info: t.tag_info
        };
}

function get_bindings(t) {
  return List.hd(t.environment.scope);
}

function call_tag_listener(key, tag, t) {
  var listener = Curry._2(Pinc_Ast.StringMap.find_opt, key, t.tag_listeners);
  if (listener !== undefined) {
    return Curry._1(listener, tag);
  } else {
    return "Null";
  }
}

Caml_module.update_mod({
      TAG: /* Module */0,
      _0: [
        [
          /* Function */0,
          "make"
        ],
        [
          /* Function */0,
          "add_scope"
        ],
        [
          /* Function */0,
          "add_value_to_scope"
        ],
        [
          /* Function */0,
          "add_value_to_function_scopes"
        ],
        [
          /* Function */0,
          "update_value_in_scope"
        ],
        [
          /* Function */0,
          "get_value_from_scope"
        ],
        [
          /* Function */0,
          "get_output"
        ],
        [
          /* Function */0,
          "add_output"
        ],
        [
          /* Function */0,
          "get_bindings"
        ],
        [
          /* Function */0,
          "call_tag_listener"
        ]
      ]
    }, State, {
      make: make,
      add_scope: add_scope,
      add_value_to_scope: add_value_to_scope,
      add_value_to_function_scopes: add_value_to_function_scopes,
      update_value_in_scope: update_value_in_scope,
      get_value_from_scope: get_value_from_scope,
      get_output: get_output,
      add_output: add_output,
      get_bindings: get_bindings,
      call_tag_listener: call_tag_listener
    });

function eval_statement(state, expression) {
  if (typeof expression === "number") {
    if (expression === /* BreakStatement */0) {
      throw {
            RE_EXN_ID: Loop_Break,
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: Loop_Continue,
          Error: new Error()
        };
  } else {
    switch (expression.TAG | 0) {
      case /* OptionalMutableLetStatement */0 :
          return eval_let(state, expression._0._0, true, true, expression._1);
      case /* OptionalLetStatement */1 :
          return eval_let(state, expression._0._0, false, true, expression._1);
      case /* MutableLetStatement */2 :
          return eval_let(state, expression._0._0, true, false, expression._1);
      case /* LetStatement */3 :
          return eval_let(state, expression._0._0, false, false, expression._1);
      case /* MutationStatement */4 :
          var ident = expression._0._0;
          var expression$1 = expression._1;
          var current_binding = Curry._2(State.get_value_from_scope, ident, state);
          if (current_binding === undefined) {
            return Stdlib.failwith("Trying to update a variable, which does not exist in the current scope.");
          }
          if (!current_binding.is_mutable) {
            return Stdlib.failwith("Trying to update a non mutable variable.");
          }
          var is_optional = current_binding.is_optional;
          var output = eval_expression({
                binding_identifier: [
                  is_optional,
                  ident
                ],
                declarations: state.declarations,
                output: state.output,
                environment: state.environment,
                tag_listeners: state.tag_listeners,
                tag_info: state.tag_info
              }, expression$1);
          var value = Curry._1(State.get_output, output);
          if (value === "Null" && !is_optional) {
            Stdlib.failwith("identifier " + (ident + " is not marked as nullable, but was tried to be updated with a null value."));
          } else {
            Curry._3(State.update_value_in_scope, ident, value, state);
          }
          return Curry._2(State.add_output, "Null", state);
      case /* ExpressionStatement */5 :
          return eval_expression(state, expression._0);
      
    }
  }
}

function eval_expression(state, i) {
  switch (i.TAG | 0) {
    case /* String */0 :
        var template = i._0;
        return Curry._2(State.add_output, {
                    NAME: "String",
                    VAL: $$String.concat("", List.map((function (s) {
                                if (s.TAG === /* StringInterpolation */0) {
                                  return Curry._1(Value.to_string, Curry._1(State.get_output, eval_expression(state, s._0)));
                                } else {
                                  return s._0;
                                }
                              }), template))
                  }, state);
    case /* Int */1 :
        return Curry._2(State.add_output, {
                    NAME: "Int",
                    VAL: i._0
                  }, state);
    case /* Float */2 :
        var f = i._0;
        if (Float.is_integer(f)) {
          return Curry._2(State.add_output, {
                      NAME: "Int",
                      VAL: f | 0
                    }, state);
        } else {
          return Curry._2(State.add_output, {
                      NAME: "Float",
                      VAL: f
                    }, state);
        }
    case /* Bool */3 :
        return Curry._2(State.add_output, {
                    NAME: "Bool",
                    VAL: i._0
                  }, state);
    case /* Array */4 :
        return Curry._2(State.add_output, {
                    NAME: "Array",
                    VAL: $$Array.map((function (it) {
                            return Curry._1(State.get_output, eval_expression(state, it));
                          }), i._0)
                  }, state);
    case /* Record */5 :
        return Curry._2(State.add_output, {
                    NAME: "Record",
                    VAL: Curry._2(Pinc_Ast.StringMap.mapi, (function (ident, param) {
                            var optional = param[0];
                            var value = Curry._1(State.get_output, eval_expression({
                                      binding_identifier: [
                                        optional,
                                        ident
                                      ],
                                      declarations: state.declarations,
                                      output: state.output,
                                      environment: state.environment,
                                      tag_listeners: state.tag_listeners,
                                      tag_info: state.tag_info
                                    }, param[1]));
                            if (value === "Null" && !optional) {
                              return Stdlib.failwith("identifier " + (ident + " is not marked as nullable, but was given a null value."));
                            } else {
                              return value;
                            }
                          }), i._0)
                  }, state);
    case /* Function */6 :
        var parameters = i._0;
        var body = i._1;
        var ident = state.binding_identifier;
        var self = {
          contents: "Null"
        };
        var exec = function ($$arguments, state, param) {
          var state$1 = ident !== undefined ? Curry._5(State.add_value_to_scope, ident[1], self.contents, false, false, state) : state;
          var state$2 = Curry._3(Pinc_Ast.StringMap.fold, (function (ident, value) {
                  return Curry._4(State.add_value_to_scope, ident, value, false, false);
                }), $$arguments, Curry._1(State.add_scope, state$1));
          return Curry._1(State.get_output, eval_expression(state$2, body));
        };
        var fn_1 = {
          parameters: parameters,
          state: state,
          exec: exec
        };
        var fn = {
          NAME: "Function",
          VAL: fn_1
        };
        $$Option.iter((function (param) {
                return Curry._5(State.add_value_to_function_scopes, param[1], fn, false, false, state);
              }), ident);
        self.contents = fn;
        return Curry._2(State.add_output, fn, state);
    case /* FunctionCall */7 :
        return eval_function_call(state, i._1, i._0);
    case /* UppercaseIdentifierExpression */8 :
        var id = i._0._0;
        var value = Curry._2(Pinc_Ast.StringMap.find_opt, id, state.declarations);
        var exists = value !== undefined ? "Exists" : "DoesntExist";
        return Curry._2(State.add_output, {
                    NAME: "DefinitionInfo",
                    VAL: [
                      id,
                      exists,
                      "NotNegated"
                    ]
                  }, state);
    case /* LowercaseIdentifierExpression */9 :
        var ident$1 = i._0._0;
        var param = Curry._2(State.get_value_from_scope, ident$1, state);
        if (param !== undefined) {
          return Curry._2(State.add_output, param.value, state);
        } else {
          return Stdlib.failwith("Unbound identifier `" + (ident$1 + "`"));
        }
    case /* TagExpression */10 :
        var tag = i._0;
        var transformer = tag.transformer;
        var tag_name = tag.tag_name;
        var is_optional = $$Option.value($$Option.map((function (prim) {
                    return prim[0];
                  }), state.binding_identifier), false);
        var attributes = Curry._2(Pinc_Ast.StringMap.map, (function (it) {
                return Curry._1(State.get_output, eval_expression({
                                binding_identifier: state.binding_identifier,
                                declarations: state.declarations,
                                output: state.output,
                                environment: state.environment,
                                tag_listeners: state.tag_listeners,
                                tag_info: true
                              }, it));
              }), tag.attributes);
        var match = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes);
        var match$1 = state.binding_identifier;
        var attributes$1 = match !== undefined ? (
            typeof match === "string" || match.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` on tag to be of type string") : attributes
          ) : (
            match$1 !== undefined ? Curry._3(Pinc_Ast.StringMap.add, "key", {
                    NAME: "String",
                    VAL: match$1[1]
                  }, attributes) : attributes
          );
        var tag_3 = function (param) {
          if (transformer === undefined) {
            return param;
          }
          var state$1 = Curry._5(State.add_value_to_scope, transformer[0]._0, param, false, false, Curry._1(State.add_scope, state));
          return Curry._1(State.get_output, eval_expression(state$1, transformer[1]));
        };
        var tag$1 = [
          tag_name,
          is_optional,
          attributes$1,
          tag_3
        ];
        var value$1 = state.tag_info ? ({
              NAME: "TagInfo",
              VAL: tag$1
            }) : Curry._3(State.call_tag_listener, "#" + tag_name, tag$1, state);
        return Curry._2(State.add_output, value$1, state);
    case /* ForInExpression */11 :
        var index_ident = i.index;
        var ident$2 = i.iterator._0;
        var reverse = i.reverse;
        var iterable = i.iterable;
        var body$1 = i.body;
        var make_rev = function (array) {
          $$Array.stable_sort((function (param, param$1) {
                  return 1;
                }), array);
          return array;
        };
        var iterable$1 = Curry._1(State.get_output, eval_expression(state, iterable));
        var maybe_rev = reverse ? make_rev : (function (arr) {
              return arr;
            });
        var index = {
          contents: -1
        };
        var loop = function (_acc, _param) {
          while(true) {
            var param = _param;
            var acc = _acc;
            if (!param) {
              return List.rev(acc);
            }
            var tl = param.tl;
            index.contents = index.contents + 1 | 0;
            var state$1 = Curry._5(State.add_value_to_scope, ident$2, param.hd, false, false, state);
            var state$2 = index_ident !== undefined ? Curry._5(State.add_value_to_scope, index_ident._0, {
                    NAME: "Int",
                    VAL: index.contents
                  }, false, false, state$1) : state$1;
            var v;
            try {
              v = eval_statement(state$2, body$1);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.RE_EXN_ID === Loop_Continue) {
                _param = tl;
                continue ;
              }
              if (exn.RE_EXN_ID === Loop_Break) {
                return List.rev(acc);
              }
              throw exn;
            }
            _param = tl;
            _acc = {
              hd: Curry._1(State.get_output, v),
              tl: acc
            };
            continue ;
          };
        };
        if (typeof iterable$1 === "string") {
          return Curry._2(State.add_output, "Null", state);
        }
        var variant = iterable$1.NAME;
        if (variant === "DefinitionInfo") {
          return Stdlib.failwith("Cannot iterate over definition info");
        }
        if (variant === "TagInfo") {
          var Internal_Error = /* @__PURE__ */Caml_exceptions.create("Internal_Error");
          throw {
                RE_EXN_ID: Internal_Error,
                Error: new Error()
              };
        }
        if (variant === "Function") {
          return Stdlib.failwith("Cannot iterate over function");
        }
        if (variant === "Int") {
          return Stdlib.failwith("Cannot iterate over int value");
        }
        if (variant === "Float") {
          return Stdlib.failwith("Cannot iterate over float value");
        }
        if (variant === "Bool") {
          return Stdlib.failwith("Cannot iterate over boolean value");
        }
        if (variant === "Record") {
          return Stdlib.failwith("Cannot iterate over record value");
        }
        if (variant === "TemplateNode") {
          return Stdlib.failwith("Cannot iterate over template node");
        }
        if (variant === "Array") {
          var res = $$Array.of_list(loop(/* [] */0, $$Array.to_list(Curry._1(maybe_rev, iterable$1.VAL))));
          return Curry._2(State.add_output, {
                      NAME: "Array",
                      VAL: res
                    }, state);
        }
        var res$1 = $$Array.of_list(loop(/* [] */0, $$Array.to_list($$Array.map((function (c) {
                            return {
                                    NAME: "String",
                                    VAL: $$String.make(1, c)
                                  };
                          }), Curry._1(maybe_rev, $$Array.of_seq($$String.to_seq(iterable$1.VAL)))))));
        return Curry._2(State.add_output, {
                    NAME: "Array",
                    VAL: res$1
                  }, state);
    case /* TemplateExpression */12 :
        return Curry._2(State.add_output, {
                    NAME: "Array",
                    VAL: $$Array.of_list(List.map((function (it) {
                                return Curry._1(State.get_output, eval_template(state, it));
                              }), i._0))
                  }, state);
    case /* BlockExpression */13 :
        var statements = i._0;
        var state$1 = Curry._1(State.add_scope, state);
        return List.fold_left((function (state) {
                      return function (param) {
                        return eval_statement(state, param);
                      };
                    }), state$1, statements);
    case /* ConditionalExpression */14 :
        var condition = i.condition;
        var alternate = i.alternate;
        var consequent = i.consequent;
        var condition_matches = Curry._1(Value.is_true, Curry._1(State.get_output, eval_expression(state, condition)));
        if (condition_matches) {
          return eval_statement(state, consequent);
        } else if (alternate !== undefined) {
          return eval_statement(state, alternate);
        } else {
          return Curry._2(State.add_output, "Null", state);
        }
    case /* UnaryExpression */15 :
        if (i._0) {
          var expression = i._1;
          var v = Curry._1(State.get_output, eval_expression(state, expression));
          if (typeof v !== "string" && v.NAME === "DefinitionInfo") {
            var match$2 = v.VAL;
            var negated = match$2[2] === "Negated" ? "NotNegated" : "Negated";
            return Curry._2(State.add_output, {
                        NAME: "DefinitionInfo",
                        VAL: [
                          match$2[0],
                          match$2[1],
                          negated
                        ]
                      }, state);
          }
          return Curry._2(State.add_output, {
                      NAME: "Bool",
                      VAL: !Curry._1(Value.is_true, v)
                    }, state);
        } else {
          var expression$1 = i._1;
          var match$3 = Curry._1(State.get_output, eval_expression(state, expression$1));
          if (typeof match$3 === "string") {
            return Stdlib.failwith("Invalid usage of unary `-` operator. You are only able to negate integers or floats.");
          }
          var variant$1 = match$3.NAME;
          if (variant$1 === "Int") {
            return Curry._2(State.add_output, {
                        NAME: "Int",
                        VAL: -match$3.VAL | 0
                      }, state);
          } else if (variant$1 === "Float") {
            return Curry._2(State.add_output, {
                        NAME: "Float",
                        VAL: -match$3.VAL
                      }, state);
          } else {
            return Stdlib.failwith("Invalid usage of unary `-` operator. You are only able to negate integers or floats.");
          }
        }
    case /* BinaryExpression */16 :
        var left = i._0;
        switch (i._1) {
          case /* EQUAL */0 :
              var right = i._2;
              var a = Curry._1(State.get_output, eval_expression(state, left));
              var b = Curry._1(State.get_output, eval_expression(state, right));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._2(Value.equal, a, b)
                        }, state);
          case /* NOT_EQUAL */1 :
              var right$1 = i._2;
              var a$1 = Curry._1(State.get_output, eval_expression(state, left));
              var b$1 = Curry._1(State.get_output, eval_expression(state, right$1));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: !Curry._2(Value.equal, a$1, b$1)
                        }, state);
          case /* GREATER */2 :
              var right$2 = i._2;
              var a$2 = Curry._1(State.get_output, eval_expression(state, left));
              var b$2 = Curry._1(State.get_output, eval_expression(state, right$2));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._2(Value.compare, a$2, b$2) > 0
                        }, state);
          case /* GREATER_EQUAL */3 :
              var right$3 = i._2;
              var a$3 = Curry._1(State.get_output, eval_expression(state, left));
              var b$3 = Curry._1(State.get_output, eval_expression(state, right$3));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._2(Value.compare, a$3, b$3) >= 0
                        }, state);
          case /* LESS */4 :
              var right$4 = i._2;
              var a$4 = Curry._1(State.get_output, eval_expression(state, left));
              var b$4 = Curry._1(State.get_output, eval_expression(state, right$4));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._2(Value.compare, a$4, b$4) < 0
                        }, state);
          case /* LESS_EQUAL */5 :
              var right$5 = i._2;
              var a$5 = Curry._1(State.get_output, eval_expression(state, left));
              var b$5 = Curry._1(State.get_output, eval_expression(state, right$5));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._2(Value.compare, a$5, b$5) <= 0
                        }, state);
          case /* PLUS */6 :
              var right$6 = i._2;
              var a$6 = Curry._1(State.get_output, eval_expression(state, left));
              var b$6 = Curry._1(State.get_output, eval_expression(state, right$6));
              if (typeof a$6 === "string") {
                return Stdlib.failwith("Trying to add non numeric literals.");
              }
              var variant$2 = a$6.NAME;
              if (variant$2 === "Int") {
                if (typeof b$6 === "string") {
                  return Stdlib.failwith("Trying to add non numeric literals.");
                }
                var variant$3 = b$6.NAME;
                var a$7 = a$6.VAL;
                if (variant$3 === "Int") {
                  return Curry._2(State.add_output, {
                              NAME: "Int",
                              VAL: a$7 + b$6.VAL | 0
                            }, state);
                } else if (variant$3 === "Float") {
                  return Curry._2(State.add_output, {
                              NAME: "Float",
                              VAL: a$7 + b$6.VAL
                            }, state);
                } else {
                  return Stdlib.failwith("Trying to add non numeric literals.");
                }
              }
              if (variant$2 !== "Float") {
                return Stdlib.failwith("Trying to add non numeric literals.");
              }
              if (typeof b$6 === "string") {
                return Stdlib.failwith("Trying to add non numeric literals.");
              }
              var variant$4 = b$6.NAME;
              var a$8 = a$6.VAL;
              if (variant$4 === "Int" || variant$4 === "Float") {
                return Curry._2(State.add_output, {
                            NAME: "Float",
                            VAL: a$8 + b$6.VAL
                          }, state);
              } else {
                return Stdlib.failwith("Trying to add non numeric literals.");
              }
          case /* MINUS */7 :
              var right$7 = i._2;
              var a$9 = Curry._1(State.get_output, eval_expression(state, left));
              var b$7 = Curry._1(State.get_output, eval_expression(state, right$7));
              if (typeof a$9 === "string") {
                return Stdlib.failwith("Trying to subtract non numeric literals.");
              }
              var variant$5 = a$9.NAME;
              if (variant$5 === "Int") {
                if (typeof b$7 === "string") {
                  return Stdlib.failwith("Trying to subtract non numeric literals.");
                }
                var variant$6 = b$7.NAME;
                var a$10 = a$9.VAL;
                if (variant$6 === "Int") {
                  return Curry._2(State.add_output, {
                              NAME: "Int",
                              VAL: a$10 - b$7.VAL | 0
                            }, state);
                } else if (variant$6 === "Float") {
                  return Curry._2(State.add_output, {
                              NAME: "Float",
                              VAL: a$10 - b$7.VAL
                            }, state);
                } else {
                  return Stdlib.failwith("Trying to subtract non numeric literals.");
                }
              }
              if (variant$5 !== "Float") {
                return Stdlib.failwith("Trying to subtract non numeric literals.");
              }
              if (typeof b$7 === "string") {
                return Stdlib.failwith("Trying to subtract non numeric literals.");
              }
              var variant$7 = b$7.NAME;
              var a$11 = a$9.VAL;
              if (variant$7 === "Int" || variant$7 === "Float") {
                return Curry._2(State.add_output, {
                            NAME: "Float",
                            VAL: a$11 - b$7.VAL
                          }, state);
              } else {
                return Stdlib.failwith("Trying to subtract non numeric literals.");
              }
          case /* TIMES */8 :
              var right$8 = i._2;
              var a$12 = Curry._1(State.get_output, eval_expression(state, left));
              var b$8 = Curry._1(State.get_output, eval_expression(state, right$8));
              if (typeof a$12 === "string") {
                return Stdlib.failwith("Trying to multiply non numeric literals.");
              }
              var variant$8 = a$12.NAME;
              if (variant$8 === "Int") {
                if (typeof b$8 === "string") {
                  return Stdlib.failwith("Trying to multiply non numeric literals.");
                }
                var variant$9 = b$8.NAME;
                var a$13 = a$12.VAL;
                if (variant$9 === "Int") {
                  return Curry._2(State.add_output, {
                              NAME: "Int",
                              VAL: Math.imul(a$13, b$8.VAL)
                            }, state);
                } else if (variant$9 === "Float") {
                  return Curry._2(State.add_output, {
                              NAME: "Float",
                              VAL: a$13 * b$8.VAL
                            }, state);
                } else {
                  return Stdlib.failwith("Trying to multiply non numeric literals.");
                }
              }
              if (variant$8 !== "Float") {
                return Stdlib.failwith("Trying to multiply non numeric literals.");
              }
              if (typeof b$8 === "string") {
                return Stdlib.failwith("Trying to multiply non numeric literals.");
              }
              var variant$10 = b$8.NAME;
              var a$14 = a$12.VAL;
              if (variant$10 === "Int" || variant$10 === "Float") {
                return Curry._2(State.add_output, {
                            NAME: "Float",
                            VAL: a$14 * b$8.VAL
                          }, state);
              } else {
                return Stdlib.failwith("Trying to multiply non numeric literals.");
              }
          case /* DIV */9 :
              var right$9 = i._2;
              var a$15 = Curry._1(State.get_output, eval_expression(state, left));
              var b$9 = Curry._1(State.get_output, eval_expression(state, right$9));
              var r;
              if (typeof a$15 === "string") {
                r = Stdlib.failwith("Trying to divide non numeric literals.");
              } else {
                var variant$11 = a$15.NAME;
                if (variant$11 === "Int") {
                  if (typeof b$9 === "string") {
                    r = Stdlib.failwith("Trying to divide non numeric literals.");
                  } else {
                    var variant$12 = b$9.NAME;
                    var a$16 = a$15.VAL;
                    if (variant$12 === "Int") {
                      var b$10 = b$9.VAL;
                      r = b$10 !== 0 ? a$16 / b$10 : Stdlib.failwith("Trying to divide by 0");
                    } else if (variant$12 === "Float") {
                      var b$11 = b$9.VAL;
                      r = b$11 !== 0 ? a$16 / b$11 : Stdlib.failwith("Trying to divide by 0");
                    } else {
                      r = Stdlib.failwith("Trying to divide non numeric literals.");
                    }
                  }
                } else if (variant$11 === "Float" && typeof b$9 !== "string") {
                  var variant$13 = b$9.NAME;
                  var a$17 = a$15.VAL;
                  if (variant$13 === "Int") {
                    var b$12 = b$9.VAL;
                    r = b$12 !== 0 ? a$17 / b$12 : Stdlib.failwith("Trying to divide by 0");
                  } else if (variant$13 === "Float") {
                    var b$13 = b$9.VAL;
                    r = b$13 !== 0 ? a$17 / b$13 : Stdlib.failwith("Trying to divide by 0");
                  } else {
                    r = Stdlib.failwith("Trying to divide non numeric literals.");
                  }
                } else {
                  r = Stdlib.failwith("Trying to divide non numeric literals.");
                }
              }
              if (Float.is_integer(r)) {
                return Curry._2(State.add_output, {
                            NAME: "Int",
                            VAL: r | 0
                          }, state);
              } else {
                return Curry._2(State.add_output, {
                            NAME: "Float",
                            VAL: r
                          }, state);
              }
          case /* POW */10 :
              var right$10 = i._2;
              var a$18 = Curry._1(State.get_output, eval_expression(state, left));
              var b$14 = Curry._1(State.get_output, eval_expression(state, right$10));
              var r$1;
              if (typeof a$18 === "string") {
                r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
              } else {
                var variant$14 = a$18.NAME;
                if (variant$14 === "Int") {
                  if (typeof b$14 === "string") {
                    r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                  } else {
                    var variant$15 = b$14.NAME;
                    var a$19 = a$18.VAL;
                    r$1 = variant$15 === "Int" || variant$15 === "Float" ? Math.pow(a$19, b$14.VAL) : Stdlib.failwith("Trying to raise non numeric literals.");
                  }
                } else if (variant$14 === "Float" && typeof b$14 !== "string") {
                  var variant$16 = b$14.NAME;
                  var a$20 = a$18.VAL;
                  r$1 = variant$16 === "Int" || variant$16 === "Float" ? Math.pow(a$20, b$14.VAL) : Stdlib.failwith("Trying to raise non numeric literals.");
                } else {
                  r$1 = Stdlib.failwith("Trying to raise non numeric literals.");
                }
              }
              if (Float.is_integer(r$1)) {
                return Curry._2(State.add_output, {
                            NAME: "Int",
                            VAL: r$1 | 0
                          }, state);
              } else {
                return Curry._2(State.add_output, {
                            NAME: "Float",
                            VAL: r$1
                          }, state);
              }
          case /* MODULO */11 :
              var right$11 = i._2;
              var a$21 = Curry._1(State.get_output, eval_expression(state, left));
              var b$15 = Curry._1(State.get_output, eval_expression(state, right$11));
              var r$2;
              if (typeof a$21 === "string") {
                r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
              } else {
                var variant$17 = a$21.NAME;
                if (variant$17 === "Int") {
                  if (typeof b$15 === "string") {
                    r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                  } else {
                    var variant$18 = b$15.NAME;
                    var a$22 = a$21.VAL;
                    if (variant$18 === "Int") {
                      var b$16 = b$15.VAL;
                      r$2 = b$16 !== 0 ? Caml_int32.mod_(a$22, b$16) : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                    } else if (variant$18 === "Float") {
                      var b$17 = b$15.VAL;
                      r$2 = b$17 !== 0 ? Caml_int32.mod_(a$22, b$17 | 0) : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                    } else {
                      r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                    }
                  }
                } else if (variant$17 === "Float" && typeof b$15 !== "string") {
                  var variant$19 = b$15.NAME;
                  var a$23 = a$21.VAL;
                  if (variant$19 === "Int") {
                    var b$18 = b$15.VAL;
                    r$2 = b$18 !== 0 ? Caml_int32.mod_(a$23 | 0, b$18) : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                  } else if (variant$19 === "Float") {
                    var b$19 = b$15.VAL;
                    r$2 = b$19 !== 0 ? a$23 % b$19 | 0 : Stdlib.failwith("Trying to modulo with 0 on right hand side.");
                  } else {
                    r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                  }
                } else {
                  r$2 = Stdlib.failwith("Trying to modulo non numeric literals.");
                }
              }
              return Curry._2(State.add_output, {
                          NAME: "Int",
                          VAL: r$2
                        }, state);
          case /* CONCAT */12 :
              var right$12 = i._2;
              var a$24 = Curry._1(State.get_output, eval_expression(state, left));
              var b$20 = Curry._1(State.get_output, eval_expression(state, right$12));
              if (typeof a$24 === "string" || !(a$24.NAME === "String" && !(typeof b$20 === "string" || b$20.NAME !== "String"))) {
                return Stdlib.failwith("Trying to concat non string literals.");
              } else {
                return Curry._2(State.add_output, {
                            NAME: "String",
                            VAL: a$24.VAL + b$20.VAL
                          }, state);
              }
          case /* AND */13 :
              var right$13 = i._2;
              var a$25 = Curry._1(State.get_output, eval_expression(state, left));
              var b$21 = Curry._1(State.get_output, eval_expression(state, right$13));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._1(Value.is_true, a$25) && Curry._1(Value.is_true, b$21)
                        }, state);
          case /* OR */14 :
              var right$14 = i._2;
              var a$26 = Curry._1(State.get_output, eval_expression(state, left));
              var b$22 = Curry._1(State.get_output, eval_expression(state, right$14));
              return Curry._2(State.add_output, {
                          NAME: "Bool",
                          VAL: Curry._1(Value.is_true, a$26) || Curry._1(Value.is_true, b$22)
                        }, state);
          case /* DOT_ACCESS */15 :
              var right$15 = i._2;
              var left$1 = Curry._1(State.get_output, eval_expression(state, left));
              if (typeof left$1 === "string") {
                if (left$1 === "Null") {
                  return Curry._2(State.add_output, "Null", state);
                }
                
              } else {
                var variant$20 = left$1.NAME;
                if (variant$20 === "Record") {
                  if (right$15.TAG !== /* LowercaseIdentifierExpression */9) {
                    return Stdlib.failwith("Expected right hand side of record access to be a lowercase identifier.");
                  }
                  var output = $$Option.value(Curry._2(Pinc_Ast.StringMap.find_opt, right$15._0._0, left$1.VAL), "Null");
                  return Curry._2(State.add_output, output, state);
                }
                if (variant$20 === "TemplateNode") {
                  if (right$15.TAG !== /* LowercaseIdentifierExpression */9) {
                    return Stdlib.failwith("I am really not sure what you are trying to do here...");
                  }
                  var b$23 = right$15._0._0;
                  var match$4 = left$1.VAL;
                  switch (b$23) {
                    case "attributes" :
                        return Curry._2(State.add_output, {
                                    NAME: "Record",
                                    VAL: match$4[2]
                                  }, state);
                    case "children" :
                        return Curry._2(State.add_output, {
                                    NAME: "Array",
                                    VAL: $$Array.of_list(match$4[3])
                                  }, state);
                    case "tag" :
                        return Curry._2(State.add_output, {
                                    NAME: "String",
                                    VAL: match$4[1]
                                  }, state);
                    default:
                      return Stdlib.failwith("Unknown property " + (b$23 + " on template node. Known properties are: `tag`, `attributes` and `children`."));
                  }
                }
                
              }
              if (right$15.TAG === /* LowercaseIdentifierExpression */9) {
                return Stdlib.failwith("Trying to access a property on a non record or template value.");
              } else {
                return Stdlib.failwith("I am really not sure what you are trying to do here...");
              }
          case /* BRACKET_ACCESS */16 :
              var right$16 = i._2;
              var left$2 = Curry._1(State.get_output, eval_expression(state, left));
              var right$17 = Curry._1(State.get_output, eval_expression(state, right$16));
              if (typeof left$2 === "string") {
                if (left$2 === "Null") {
                  return Curry._2(State.add_output, "Null", state);
                } else {
                  return Stdlib.failwith("Trying to access a property on a non record or array value.");
                }
              }
              var variant$21 = left$2.NAME;
              if (variant$21 === "Record") {
                if (typeof right$17 === "string") {
                  return Stdlib.failwith("Cannot access record with a non string value.");
                }
                if (right$17.NAME !== "String") {
                  return Stdlib.failwith("Cannot access record with a non string value.");
                }
                var output$1 = $$Option.value(Curry._2(Pinc_Ast.StringMap.find_opt, right$17.VAL, left$2.VAL), "Null");
                return Curry._2(State.add_output, output$1, state);
              }
              if (variant$21 !== "Array") {
                return Stdlib.failwith("Trying to access a property on a non record or array value.");
              }
              if (typeof right$17 === "string") {
                return Stdlib.failwith("Cannot access array with a non integer value.");
              }
              if (right$17.NAME !== "Int") {
                return Stdlib.failwith("Cannot access array with a non integer value.");
              }
              var output$2;
              try {
                output$2 = Caml_array.get(left$2.VAL, right$17.VAL);
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID === Stdlib.Invalid_argument) {
                  output$2 = "Null";
                } else {
                  throw exn;
                }
              }
              return Curry._2(State.add_output, output$2, state);
          case /* FUNCTION_CALL */17 :
              return eval_function_call(state, {
                          hd: i._2,
                          tl: /* [] */0
                        }, left);
          case /* PIPE */18 :
              var right$18 = i._2;
              var right$19;
              right$19 = right$18.TAG === /* FunctionCall */7 ? ({
                    TAG: /* FunctionCall */7,
                    _0: right$18._0,
                    _1: {
                      hd: left,
                      tl: right$18._1
                    }
                  }) : ({
                    TAG: /* FunctionCall */7,
                    _0: right$18,
                    _1: {
                      hd: left,
                      tl: /* [] */0
                    }
                  });
              return eval_expression(state, right$19);
          case /* ARRAY_ADD */19 :
              var right$20 = i._2;
              var left$3 = Curry._1(State.get_output, eval_expression(state, left));
              var right$21 = Curry._1(State.get_output, eval_expression(state, right$20));
              if (typeof left$3 === "string" || left$3.NAME !== "Array") {
                return Stdlib.failwith("Trying to add an element on a non array value.");
              } else {
                return Curry._2(State.add_output, {
                            NAME: "Array",
                            VAL: $$Array.append(left$3.VAL, [right$21])
                          }, state);
              }
          case /* MERGE */20 :
              var right$22 = i._2;
              var left$4 = Curry._1(State.get_output, eval_expression(state, left));
              var right$23 = Curry._1(State.get_output, eval_expression(state, right$22));
              if (typeof left$4 !== "string") {
                var variant$22 = left$4.NAME;
                if (variant$22 === "Record") {
                  if (typeof right$23 !== "string" && right$23.NAME === "Record") {
                    return Curry._2(State.add_output, {
                                NAME: "Record",
                                VAL: Curry._3(Pinc_Ast.StringMap.union, (function (_key, _x, y) {
                                        return y;
                                      }), left$4.VAL, right$23.VAL)
                              }, state);
                  }
                  
                } else {
                  if (variant$22 === "TemplateNode") {
                    var match$5 = left$4.VAL;
                    if (typeof right$23 === "string") {
                      return Stdlib.failwith("Trying to merge a non record value onto tag attributes.");
                    }
                    if (right$23.NAME !== "Record") {
                      return Stdlib.failwith("Trying to merge a non record value onto tag attributes.");
                    }
                    var attributes$2 = Curry._3(Pinc_Ast.StringMap.union, (function (_key, _x, y) {
                            return y;
                          }), match$5[2], right$23.VAL);
                    return Curry._2(State.add_output, {
                                NAME: "TemplateNode",
                                VAL: [
                                  match$5[0],
                                  match$5[1],
                                  attributes$2,
                                  match$5[3],
                                  match$5[4]
                                ]
                              }, state);
                  }
                  if (variant$22 === "Array") {
                    if (typeof right$23 === "string" || right$23.NAME !== "Array") {
                      return Stdlib.failwith("Trying to merge a non array value onto an array.");
                    } else {
                      return Curry._2(State.add_output, {
                                  NAME: "Array",
                                  VAL: $$Array.append(left$4.VAL, right$23.VAL)
                                }, state);
                    }
                  }
                  
                }
              }
              if (typeof right$23 === "string" || right$23.NAME !== "Array") {
                return Stdlib.failwith("Trying to merge two non array values.");
              } else {
                return Stdlib.failwith("Trying to merge an array value onto a non array.");
              }
          case /* RANGE */21 :
              return eval_range(state, false, left, i._2);
          case /* INCLUSIVE_RANGE */22 :
              return eval_range(state, true, left, i._2);
          
        }
    
  }
}

function eval_function_call(state, $$arguments, left) {
  var maybe_fn = Curry._1(State.get_output, eval_expression(state, left));
  if (typeof maybe_fn === "string") {
    return Stdlib.failwith("Trying to call a non function value");
  }
  if (maybe_fn.NAME !== "Function") {
    return Stdlib.failwith("Trying to call a non function value");
  }
  var match = maybe_fn.VAL;
  var parameters = match.parameters;
  if (List.compare_lengths(parameters, $$arguments) === 0) {
    var $$arguments$1 = List.fold_left((function (acc, param) {
            var value = Curry._1(State.get_output, eval_expression(state, param[1]));
            return Curry._3(Pinc_Ast.StringMap.add, param[0], value, acc);
          }), Pinc_Ast.StringMap.empty, List.combine(parameters, $$arguments));
    return Curry._2(State.add_output, Curry._3(match.exec, $$arguments$1, match.state, undefined), state);
  }
  if (List.compare_lengths(parameters, $$arguments) <= 0) {
    return Stdlib.failwith("This function only accepts " + (String(List.length(parameters)) + (" arguments, but was provided " + (String(List.length($$arguments)) + " here."))));
  }
  var arguments_len = List.length($$arguments);
  var missing = $$String.concat(", ", List.map((function (item) {
              return "`" + (item + "`");
            }), List.filteri((function (index, param) {
                  return index > (arguments_len - 1 | 0);
                }), parameters)));
  return Stdlib.failwith("This function was provided too few arguments. The following parameters are missing: " + missing);
}

function eval_let(state, ident, is_mutable, is_optional, expression) {
  var state$1 = eval_expression({
        binding_identifier: [
          is_optional,
          ident
        ],
        declarations: state.declarations,
        output: state.output,
        environment: state.environment,
        tag_listeners: state.tag_listeners,
        tag_info: state.tag_info
      }, expression);
  var value = Curry._1(State.get_output, state$1);
  if (value === "Null" && !is_optional) {
    return Stdlib.failwith("identifier " + (ident + " is not marked as nullable, but was given a null value."));
  }
  return Curry._2(State.add_output, "Null", Curry._5(State.add_value_to_scope, ident, value, is_optional, is_mutable, state$1));
}

function eval_range(state, inclusive, from, upto) {
  var from$1 = Curry._1(State.get_output, eval_expression(state, from));
  var upto$1 = Curry._1(State.get_output, eval_expression(state, upto));
  var match;
  var exit = 0;
  if (typeof from$1 === "string" || from$1.NAME !== "Int") {
    exit = 1;
  } else {
    match = typeof upto$1 === "string" || upto$1.NAME !== "Int" ? Stdlib.failwith("Can't construct range in for loop. The end of your range is not of type int.") : [
        from$1.VAL,
        upto$1.VAL
      ];
  }
  if (exit === 1) {
    match = typeof upto$1 === "string" || upto$1.NAME !== "Int" ? Stdlib.failwith("Can't construct range in for loop. The start and end of your range are not of type int.") : Stdlib.failwith("Can't construct range in for loop. The start of your range is not of type int.");
  }
  var upto$2 = match[1];
  var from$2 = match[0];
  var iter;
  if (from$2 > upto$2) {
    iter = [];
  } else {
    var stop = inclusive ? upto$2 + 1 | 0 : upto$2;
    iter = $$Array.init(stop - from$2 | 0, (function (i) {
            return {
                    NAME: "Int",
                    VAL: i + from$2 | 0
                  };
          }));
  }
  return Curry._2(State.add_output, {
              NAME: "Array",
              VAL: iter
            }, state);
}

function eval_template(state, template) {
  switch (template.TAG | 0) {
    case /* HtmlTemplateNode */0 :
        var attributes = Curry._2(Pinc_Ast.StringMap.map, State.get_output, Curry._2(Pinc_Ast.StringMap.map, (function (param) {
                    return eval_expression(state, param);
                  }), template.attributes));
        var children = List.map(State.get_output, List.map((function (param) {
                    return eval_template(state, param);
                  }), template.children));
        return Curry._2(State.add_output, {
                    NAME: "TemplateNode",
                    VAL: [
                      "Html",
                      template.tag,
                      attributes,
                      children,
                      template.self_closing
                    ]
                  }, state);
    case /* ComponentTemplateNode */1 :
        var tag = template.identifier._0;
        var attributes$1 = Curry._2(Pinc_Ast.StringMap.map, State.get_output, Curry._2(Pinc_Ast.StringMap.map, (function (param) {
                    return eval_expression(state, param);
                  }), template.attributes));
        var children$1 = List.map(State.get_output, List.map((function (param) {
                    return eval_template(state, param);
                  }), template.children));
        var component_tag_listeters = Curry._3(Pinc_Ast.StringMap.add, "#Slot", (function (param) {
                var transformer = param[3];
                var attributes = param[2];
                var param$1 = $$Option.value(Curry._2(Pinc_Ast.StringMap.find_opt, "name", attributes), {
                      NAME: "String",
                      VAL: ""
                    });
                var slot_name = typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `name` on #Slot to be of type string.") : param$1.VAL;
                var param$2 = $$Option.value(Curry._2(Pinc_Ast.StringMap.find_opt, "min", attributes), {
                      NAME: "Int",
                      VAL: 0
                    });
                var min = typeof param$2 === "string" || param$2.NAME !== "Int" ? Stdlib.failwith("Expected attribute `min` on #Slot to be of type int.") : param$2.VAL;
                var param$3 = Curry._2(Pinc_Ast.StringMap.find_opt, "max", attributes);
                var max = param$3 !== undefined ? (
                    typeof param$3 === "string" || param$3.NAME !== "Int" ? Stdlib.failwith("Expected attribute `max` on #Slot to be of type int.") : param$3.VAL
                  ) : undefined;
                var param$4 = Curry._2(Pinc_Ast.StringMap.find_opt, "instanceOf", attributes);
                var instanceOf = param$4 !== undefined ? (
                    typeof param$4 === "string" || param$4.NAME !== "Array" ? Stdlib.failwith("Expected attribute `instanceOf` on #Slot to be an array.") : $$Array.map((function (param) {
                              if (typeof param === "string" || param.NAME !== "DefinitionInfo") {
                                return Stdlib.failwith("Expected attribute `instanceOf` on #Slot to be an array of uppercase identifiers.");
                              } else {
                                return param.VAL;
                              }
                            }), param$4.VAL)
                  ) : undefined;
                var find_slot_key = function (attributes) {
                  var param = $$Option.value(Curry._2(Pinc_Ast.StringMap.find_opt, "slot", attributes), {
                        NAME: "String",
                        VAL: ""
                      });
                  if (typeof param === "string" || param.NAME !== "String") {
                    return Stdlib.failwith("Expected slot attribute to be of type string");
                  } else {
                    return param.VAL;
                  }
                };
                var keep_slotted = function (acc, value) {
                  var tag;
                  var attributes;
                  if (typeof value === "string") {
                    return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
                  }
                  var variant = value.NAME;
                  if (variant === "String") {
                    if ($$String.trim(value.VAL) === "") {
                      return acc;
                    } else {
                      return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
                    }
                  }
                  if (variant !== "TemplateNode") {
                    if (variant === "Array") {
                      return $$Array.fold_left(keep_slotted, acc, value.VAL);
                    } else {
                      return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
                    }
                  }
                  var match = value.VAL;
                  var match$1 = match[0];
                  if (typeof match$1 === "string") {
                    if (match$1 !== "Html") {
                      return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
                    }
                    tag = match[1];
                    attributes = match[2];
                  } else {
                    if (match$1.NAME !== "Component") {
                      return Stdlib.failwith("Only nodes may be placed into slots. If you want to put a plain text into a slot, you have to wrap it in a <p></p> tag for example.");
                    }
                    tag = match[1];
                    attributes = match[2];
                  }
                  if (find_slot_key(attributes) === slot_name) {
                    var f = $$Array.append(acc, [value]);
                    if (instanceOf === undefined) {
                      return f;
                    }
                    var is_in_list = {
                      contents: false
                    };
                    var match$2 = List.partition_map((function (param) {
                            var name = param[0];
                            if (name === tag) {
                              is_in_list.contents = true;
                            }
                            if (param[2] === "Negated") {
                              return Either.right(name);
                            } else {
                              return Either.left(name);
                            }
                          }), $$Array.to_list(instanceOf));
                    var allowed = match$2[0];
                    var is_in_list$1 = is_in_list.contents;
                    var is_allowed = allowed ? (
                        match$2[1] ? List.mem(tag, allowed) : is_in_list$1
                      ) : !is_in_list$1;
                    if (is_allowed) {
                      return f;
                    }
                    var arg = [];
                    return Stdlib.failwith("Child with tag `" + (tag + ("` may not be used inside the " + ((
                                      slot_name === "" ? "Default #Slot." : "#Slot with name `" + (slot_name + "`")
                                    ) + (". The following restrictions are set: [ " + ($$String.concat(",", List.map((function (param) {
                                                    var name = param[0];
                                                    if (param[2] === "Negated") {
                                                      return "!" + name;
                                                    } else {
                                                      return name;
                                                    }
                                                  }), $$Array.to_list((function (param) {
                                                          return $$Option.value(param, arg);
                                                        })(instanceOf)))) + " ]"))))));
                  } else {
                    return acc;
                  }
                };
                var slotted_children = $$Array.fold_left(keep_slotted, [], $$Array.of_list(children$1));
                var amount_of_children = slotted_children.length;
                var exit = 0;
                if (slot_name === "") {
                  if (amount_of_children < min) {
                    return Stdlib.failwith("Default #Slot did not reach the minimum amount of nodes (specified as " + (String(min) + ")."));
                  }
                  exit = 2;
                } else {
                  exit = 2;
                }
                if (exit === 2) {
                  if (amount_of_children < min) {
                    return Stdlib.failwith("#Slot with name `" + (slot_name + ("` did not reach the minimum amount of nodes (specified as " + (String(min) + ")."))));
                  }
                  if (slot_name === "") {
                    if (max === undefined) {
                      return Curry._1(transformer, {
                                  NAME: "Array",
                                  VAL: slotted_children
                                });
                    }
                    if (amount_of_children > max) {
                      return Stdlib.failwith("Default #Slot includes more than the maximum amount of nodes (specified as " + (String(max) + ")."));
                    }
                    
                  }
                  
                }
                if (max !== undefined && amount_of_children > max) {
                  return Stdlib.failwith("#Slot with name `" + (slot_name + ("` includes more than the maximum amount of nodes (specified as " + (String(max) + ")."))));
                } else {
                  return Curry._1(transformer, {
                              NAME: "Array",
                              VAL: slotted_children
                            });
                }
              }), Curry._3(Pinc_Ast.StringMap.add, "#Record", (function (param) {
                    var attributes$2 = param[2];
                    var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes$2);
                    var key = param$1 !== undefined ? (
                        typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Record to be of type string") : param$1.VAL
                      ) : Stdlib.failwith("Expected attribute `key` to exist on #Record");
                    var param$2 = Curry._2(Pinc_Ast.StringMap.find_opt, "of", attributes$2);
                    var of$p = param$2 !== undefined ? (
                        typeof param$2 === "string" || param$2.NAME !== "Record" ? Stdlib.failwith("Expected attribute `of` #Array to be a tag describing the type of the items inside.") : Curry._2(Pinc_Ast.StringMap.filter_map, (function (_key, param) {
                                  if (typeof param === "string" || param.NAME !== "TagInfo") {
                                    return ;
                                  } else {
                                    return param.VAL;
                                  }
                                }), param$2.VAL)
                      ) : Stdlib.failwith("Expected attribute `of` to exist on #Record");
                    var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes$2);
                    var v = Curry._2(Pinc_Ast.StringMap.find_opt, key, attributes$1);
                    var param$3 = validate$5($$Option.value(v !== undefined ? v : $$default, "Null"));
                    return Curry._1(param[3], typeof param$3 === "string" ? "Null" : ({
                                    NAME: "Record",
                                    VAL: Curry._2(Pinc_Ast.StringMap.mapi, (function (key, value) {
                                            var param = Curry._2(Pinc_Ast.StringMap.find_opt, key, of$p);
                                            if (param !== undefined) {
                                              return Curry._1(param[3], value);
                                            } else {
                                              return value;
                                            }
                                          }), param$3.VAL)
                                  }));
                  }), Curry._3(Pinc_Ast.StringMap.add, "#Array", (function (param) {
                        var attributes$2 = param[2];
                        var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes$2);
                        var key = param$1 !== undefined ? (
                            typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Array to be of type string") : param$1.VAL
                          ) : Stdlib.failwith("Expected attribute `key` to exist on #Array");
                        var param$2 = Curry._2(Pinc_Ast.StringMap.find_opt, "of", attributes$2);
                        var of$p = param$2 !== undefined ? (
                            typeof param$2 === "string" || param$2.NAME !== "TagInfo" ? Stdlib.failwith("Expected attribute `of` #Array to be a tag describing the type of the items inside.") : param$2.VAL[3]
                          ) : Stdlib.failwith("Expected attribute `of` to exist on #Array");
                        var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes$2);
                        var v = Curry._2(Pinc_Ast.StringMap.find_opt, key, attributes$1);
                        var param$3 = validate$4($$Option.value(v !== undefined ? v : $$default, "Null"));
                        return Curry._1(param[3], typeof param$3 === "string" ? "Null" : ({
                                        NAME: "Array",
                                        VAL: $$Array.map(Curry.__1(of$p), param$3.VAL)
                                      }));
                      }), Curry._3(Pinc_Ast.StringMap.add, "#Boolean", (function (param) {
                            var attributes$2 = param[2];
                            var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes$2);
                            var key = param$1 !== undefined ? (
                                typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Boolean to be of type string") : param$1.VAL
                              ) : Stdlib.failwith("Expected attribute `key` to exist on #Boolean");
                            var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes$2);
                            var v = Curry._2(Pinc_Ast.StringMap.find_opt, key, attributes$1);
                            return Curry._1(param[3], validate$3($$Option.value(v !== undefined ? v : $$default, "Null")));
                          }), Curry._3(Pinc_Ast.StringMap.add, "#Float", (function (param) {
                                var attributes$2 = param[2];
                                var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes$2);
                                var key = param$1 !== undefined ? (
                                    typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Float to be of type string") : param$1.VAL
                                  ) : Stdlib.failwith("Expected attribute `key` to exist on #Float");
                                var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes$2);
                                var v = Curry._2(Pinc_Ast.StringMap.find_opt, key, attributes$1);
                                return Curry._1(param[3], validate$2($$Option.value(v !== undefined ? v : $$default, "Null")));
                              }), Curry._3(Pinc_Ast.StringMap.add, "#Int", (function (param) {
                                    var attributes$2 = param[2];
                                    var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes$2);
                                    var key = param$1 !== undefined ? (
                                        typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #Int to be of type string") : param$1.VAL
                                      ) : Stdlib.failwith("Expected attribute `key` to exist on #Int");
                                    var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes$2);
                                    var v = Curry._2(Pinc_Ast.StringMap.find_opt, key, attributes$1);
                                    return Curry._1(param[3], validate$1($$Option.value(v !== undefined ? v : $$default, "Null")));
                                  }), Curry._3(Pinc_Ast.StringMap.add, "#String", (function (param) {
                                        var attributes$2 = param[2];
                                        var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "key", attributes$2);
                                        var key = param$1 !== undefined ? (
                                            typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `key` #String to be of type string") : param$1.VAL
                                          ) : Stdlib.failwith("Expected attribute `key` to exist on #String");
                                        var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes$2);
                                        var v = Curry._2(Pinc_Ast.StringMap.find_opt, key, attributes$1);
                                        return Curry._1(param[3], validate($$Option.value(v !== undefined ? v : $$default, "Null")));
                                      }), Pinc_Ast.StringMap.empty)))))));
        var tag_listeners = Curry._3(Pinc_Ast.StringMap.union, (function (_key, _x, y) {
                return y;
              }), state.tag_listeners, component_tag_listeters);
        var render_fn = function (param) {
          var state$1 = Curry._2(State.make, Caml_option.some(tag_listeners), state.declarations);
          var declaration = Curry._2(Pinc_Ast.StringMap.find_opt, tag, state$1.declarations);
          return Curry._1(State.get_output, declaration !== undefined ? eval_declaration(state$1, declaration) : Stdlib.failwith("Declaration with name `" + (tag + "` was not found.")));
        };
        return Curry._2(State.add_output, {
                    NAME: "TemplateNode",
                    VAL: [
                      {
                        NAME: "Component",
                        VAL: render_fn
                      },
                      tag,
                      attributes$1,
                      children$1,
                      false
                    ]
                  }, state);
    case /* ExpressionTemplateNode */2 :
        return eval_expression(state, template._0);
    case /* TextTemplateNode */3 :
        return Curry._2(State.add_output, {
                    NAME: "String",
                    VAL: template._0
                  }, state);
    
  }
}

function eval_declaration(state, declaration) {
  return eval_expression(state, declaration._1);
}

function $$eval(tag_listeners, root, declarations) {
  var context = Hashtbl.create(undefined, 10);
  var default_tag_listeters = Curry._3(Pinc_Ast.StringMap.add, "#GetContext", (function (param) {
          var attributes = param[2];
          var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "name", attributes);
          var name = param$1 !== undefined ? (
              typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `name` on #GetContext to be of type string.") : param$1.VAL
            ) : Stdlib.failwith("attribute name is required when getting a context.");
          var $$default = Curry._2(Pinc_Ast.StringMap.find_opt, "default", attributes);
          var v = Hashtbl.find_opt(context, name);
          return Curry._1(param[3], validate$7($$Option.value(v !== undefined ? v : $$default, "Null")));
        }), Curry._3(Pinc_Ast.StringMap.add, "#SetContext", (function (param) {
              var attributes = param[2];
              var param$1 = Curry._2(Pinc_Ast.StringMap.find_opt, "name", attributes);
              var name = param$1 !== undefined ? (
                  typeof param$1 === "string" || param$1.NAME !== "String" ? Stdlib.failwith("Expected attribute `name` on #SetContext to be of type string.") : param$1.VAL
                ) : Stdlib.failwith("attribute name is required when setting a context.");
              var value = Curry._2(Pinc_Ast.StringMap.find_opt, "value", attributes);
              var value$1 = value !== undefined ? value : Stdlib.failwith("attribute value is required when setting a context.");
              Hashtbl.add(context, name, value$1);
              return Curry._1(param[3], validate$6("Null"));
            }), Pinc_Ast.StringMap.empty));
  var tag_listeners$1 = tag_listeners !== undefined ? Curry._3(Pinc_Ast.StringMap.union, (function (_key, x, _y) {
            return x;
          }), Caml_option.valFromOption(tag_listeners), default_tag_listeters) : default_tag_listeters;
  var state = Curry._2(State.make, Caml_option.some(tag_listeners$1), declarations);
  var declaration = Curry._2(Pinc_Ast.StringMap.find_opt, root, declarations);
  if (declaration !== undefined) {
    return eval_declaration(state, declaration);
  } else {
    return Stdlib.failwith("Declaration with name `" + (root + "` was not found."));
  }
}

function from_source(filenameOpt, source, root) {
  var filename = filenameOpt !== undefined ? filenameOpt : "";
  var declarations = Pinc_Parser.parse(filename, source);
  return $$eval(undefined, root, declarations);
}

var Value_to_string = Value.to_string;

var Value_null = Value.$$null;

var Value_of_string = Value.of_string;

var Value_of_bool = Value.of_bool;

var Value_of_int = Value.of_int;

var Value_of_float = Value.of_float;

var Value_of_list = Value.of_list;

var Value_of_string_map = Value.of_string_map;

var Value_make_component = Value.make_component;

var Value$1 = {
  to_string: Value_to_string,
  $$null: Value_null,
  of_string: Value_of_string,
  of_bool: Value_of_bool,
  of_int: Value_of_int,
  of_float: Value_of_float,
  of_list: Value_of_list,
  of_string_map: Value_of_string_map,
  make_component: Value_make_component
};

var Tag;

var State_get_output = State.get_output;

var State_get_bindings = State.get_bindings;

var State$1 = {
  get_output: State_get_output,
  get_bindings: State_get_bindings
};

export {
  Value$1 as Value,
  Tag ,
  State$1 as State,
  $$eval ,
  from_source ,
}
/* Value Not a pure module */
